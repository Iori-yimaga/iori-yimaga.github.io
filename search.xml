<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>玩转命令行之文本编辑器篇</title>
      <link href="/post/d3a7b34f.html"/>
      <url>/post/d3a7b34f.html</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-事情是这样子的"><a href="#0x00-事情是这样子的" class="headerlink" title="0x00 事情是这样子的"></a>0x00 事情是这样子的</h3><p>折腾的时光总是快乐的，目前空闲下来了，就开始想象有啥活可以整的，老早就想着写一篇软件分享的文章，可是也没啥好推荐的，昨天在看到一篇介绍文本编辑器的文章后突然脑洞大开，那我就来点不一样的呗～命令行下的文本编辑器，硬核吧，（大佬请自行绕过，<del>没错，就是来吓唬小白的</del>）</p><div class="note info modern"><p>一下介绍性的文字均来自咕噜咕噜和菜鸟教程，感兴趣的可以自行搜索。</p></div><h3 id="0x01-正式分享"><a href="#0x01-正式分享" class="headerlink" title="0x01 正式分享"></a>0x01 正式分享</h3><h4 id="1、vi-vim"><a href="#1、vi-vim" class="headerlink" title="1、vi/vim "></a>1、vi/vim <img src="https://pic1.zhimg.com/v2-53579b05d8e5a22e4700170a6132db04_1440w.jpg?source=172ae18b" alt="vi/vim" style="zoom:2%;" /></h4><h5 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h5><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages2015.cnblogs.com%2Fblog%2F950881%2F201612%2F950881-20161202182446224-1838726353.png&refer=http%3A%2F%2Fimages2015.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1629593081&t=7cef302d21a212c68c8fa50a34ef41f7" alt="vim" style="zoom:70%;" /></p><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p><p>但是目前我们使用比较多的是 vim 编辑器。</p><p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><h5 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h5><p>由于所有的linux/unix系统都自带了vi，那我这里就讲讲vim的安装吧，（windows就算了，有notepad）很简单，用包管理器直接安装即可，这里重点讲一下我的vim美化/优化方法：D</p><p>介绍一个vim的第三方主题扩展包：<a href="https://spacevim.org/cn/">spacevim</a>，首先我们来看看它的样子：</p><p><img src="https://user-images.githubusercontent.com/13142418/121829909-64cb5380-ccf6-11eb-9d5a-f576fa63e69c.png" style="zoom:75%;" /></p><p>怎么样，是不是很好看呢，我们在终端里输入这条命令即可直接安装到你的vim配置文件中，下次启动直接就变成sapcevim的界面了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sLf https://spacevim.org/install.sh | bash</span><br></pre></td></tr></table></figure><p>Tips：初次启动会要你选择模式，选择后退出，第二次进入会自动安装初始扩展，等待一下就好。当然后续的插件扩展我们都可以自行DIY，官网里介绍的非常详细我就不多赘述了。</p><h5 id="1-3-使用方式"><a href="#1-3-使用方式" class="headerlink" title="1.3 使用方式"></a>1.3 使用方式</h5><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p><div class="tabs" id="三种模式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#三种模式-1">Command mode</button></li><li class="tab"><button type="button" data-href="#三种模式-2">Insert mode</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="三种模式-1"><p>用户刚刚启动 vi/vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><p>以下是常用的几个命令：</p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul><p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p><p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="三种模式-2"><p>在命令模式下按下i就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li><li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>来张题把这三种模式串一下大家就会很明白了：</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/vim-vi-workmodel.webp" alt="vim-vi-workmodel" style="zoom:80%;" /></p><h5 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h5><p>总体来说，vi/vim我还是非常推荐的，方便简单是他的代名词，而且命令也不难记，上手几次就熟悉了，而且可扩展性也强，可玩性高，也好看（重点），谁不想有个用起来趁手又好看的工具呢，对处理单个文件的时候就很很方便，不用开IDE那种重型软件。</p><h4 id="2、Emacs"><a href="#2、Emacs" class="headerlink" title="2、Emacs "></a>2、Emacs <img src="http://www.gnu.org/software/emacs/images/gnu.transparent.png" alt="gnu" style="zoom:25%;" /></h4><h5 id="2-1-介绍（看看就行）"><a href="#2-1-介绍（看看就行）" class="headerlink" title="2.1 介绍（看看就行）"></a>2.1 介绍<del>（看看就行）</del></h5><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages.cnitblog.com%2Fblog%2F574825%2F201404%2F270720519663242.png&refer=http%3A%2F%2Fimages.cnitblog.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1629600167&t=dc50aa909fb5c6f500d56240cc1159c0" alt="emacs" style="zoom:80%;" /></p><p>Emacs，著名的<a href="https://baike.baidu.com/item/集成开发环境/298524">集成开发环境</a>和文本<a href="https://baike.baidu.com/item/编辑器">编辑器</a>。Emacs被公认为是最受专业程序员喜爱的代码编辑器之一，另外一个<a href="https://baike.baidu.com/item/vim/60410">vim</a>。</p><p>EMACS，即Editor MACroS（编辑器宏）的缩写，最初由Richard Stallman于1975年在<a href="https://baike.baidu.com/item/MIT/31539">MIT</a>协同<a href="https://baike.baidu.com/item/Guy Steele">Guy Steele</a>共同完成。这一创意的灵感来源于TECMAC和TMACS，它们是由Guy Steele、Dave Moon、Richard Greenblatt、Charles Frankston等人编写的宏<a href="https://baike.baidu.com/item/文本编辑器">文本编辑器</a>。</p><p>自诞生以来，Emacs演化出了众多分支，其中使用最广泛的两种是：1984年由Richard Stallman发起并由他维护至今的GNU Emacs，以及1991年发起的XEmacs。XEmacs是GNU Emacs的分支，至今仍保持着相当的兼容性。</p><p>Emacs使用Emacs Lisp，这种有着极强扩展性的编程语言，从而实现了包括编程、<a href="https://baike.baidu.com/item/编译/1258343">编译</a>乃至网络浏览等等功能的扩展。</p><h5 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h5><p>windows用户可以直接去官网下载二进制安装包文件，打开即用，linux/unix系用户、MacOS用户就用包管理器吧，当然也可以下载二进制文件。</p><h5 id="2-3-使用方式"><a href="#2-3-使用方式" class="headerlink" title="2.3 使用方式"></a>2.3 使用方式</h5><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/tieba_emotion_82.png" alt="tieba_emotion_82" style="zoom:50%;" />我我我，这个真不会，但也许你会喜欢下面几个详细介绍：<img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/tieba_emotion_16.png" alt="tieba_emotion_16" style="zoom:50%;" /></p><div class="tag link"><a class="link-card" title="Emacs保姆级入门讲解" href="https://www.bilibili.com/video/BV19p4y1X7W3"><div class="left"><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/5H8ktr.png"/></div><div class="right"><p class="text">Emacs保姆级入门讲解</p><p class="url">https://www.bilibili.com/video/BV19p4y1X7W3</p></div></a></div><h5 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h5><p>Emacs主要依赖各种快捷键的组合来实现功能，确实挺“方便”的，丢掉了鼠标，但是太多了，对新人不是很友好，但是你耐心的学习一段时间后，又会发现好像打开了新的大门，特别是配合Lisp脚本来拓展插件之后，又会觉得哇塞，这玩意真棒👍说是小型的vscode也不为过，可以聊天、收发邮件、听歌等等，等待大家探索。</p><p><del>玩会了来教我</del></p><h4 id="3、helix-editor-Logo"><a href="#3、helix-editor-Logo" class="headerlink" title="3、helix editor (Logo)"></a>3、helix editor <del>(Logo)</del></h4><h5 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h5><p>这个就是我昨天看的文章里介绍的一款比较新的文本编辑器，相对于前面的两位老前辈，这个就年轻了。</p><p><a href="https://link.zhihu.com/?target=https%3A//helix-editor.com/">Helix</a> 是用 Rust 编写的，使用 Tree-sitter 进行语法高亮。开发者声称，它比正则表达式高亮更快，因为 Tree-sitter 像编译器一样将代码解析成语法树，从而给出更多的代码结构信息。</p><p>你可以跟踪局部变量，计算缩进和操作选择来选择语法节点。它足够强大，即使有语法错误也能产生结果。</p><p>Helix 的主要亮点是“多重选择”，这是基于 <a href="https://link.zhihu.com/?target=http%3A//kakoune.org/">Kakoune</a> 的。</p><p>内置的语言服务器支持提供上下文感知补全、诊断和代码操作。</p><h5 id="3-2-安装"><a href="#3-2-安装" class="headerlink" title="3.2 安装"></a>3.2 安装</h5><p>各大平台均可使用包管理器安装，windows除外（微软：那我走？），但是本着折腾和geek精神，咱们来自编译🤪。</p><p>前提是装好rust环境和cargo包，然后按照如下顺序输入命令进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recurse-submodules --shallow-submodules -j8 https://github.com/helix-editor/helix</span><br><span class="line"><span class="built_in">cd</span> helix</span><br><span class="line">cargo install --path helix-term</span><br></pre></td></tr></table></figure><p>其实完成这一步后，咱们在终端就可以使用<code>hx</code>来呼出hexlix editor了，但是你想要全局呼出的话，需要安装它的运行时，也就是runtime：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install --path helix-term --features <span class="string">&quot;embed_runtime&quot;</span></span><br></pre></td></tr></table></figure><h5 id="3-3-使用"><a href="#3-3-使用" class="headerlink" title="3.3 使用"></a>3.3 使用</h5><p>其实操作上很像vi/vim，但是多了一些提示框和动态的效果，看起来更具现代感</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/vQCuaE.png" alt="vQCuaE" style="zoom:80%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/cUAMb0.png" alt="cUAMb0" style="zoom:80%;" /></p><h5 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h5><p>用习惯vi/vim的用户来说，可以平滑过渡到这个工具上来，确实挺不错的，我决定要用一段时间了，自编译的还是香～</p><h3 id="0x02-我想要说的话"><a href="#0x02-我想要说的话" class="headerlink" title="0x02 我想要说的话"></a>0x02 我想要说的话</h3><p>emmmm怎么感觉完全就是vim/vim的专场？？？其实不是，只是个人习惯使用而已，emacs作为编辑器界的鼻祖，更有emacs就是个操作系统的说法，只是我太菜了<img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/d_erha.png" alt="d_erha" style="zoom:25%;" />大家完全可以凭借自己的喜好去选择自己想要的，当然，适合自己的才是最好的嘛。</p>]]></content>
      
      
      <categories>
          
          <category> 好物分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令行 </tag>
            
            <tag> 文本编辑器 </tag>
            
            <tag> linux/unix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openwrt踩坑之旅</title>
      <link href="/post/b88e454f.html"/>
      <url>/post/b88e454f.html</url>
      
        <content type="html"><![CDATA[<h3 id="0x11-重点鸣谢"><a href="#0x11-重点鸣谢" class="headerlink" title="0x11 重点鸣谢"></a>0x11 重点鸣谢</h3><details yellow><summary> Openwrt官方项目 </summary>              <div class='content'>              <p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/openwrt/openwrt"><img src="https://github-readme-stats.vercel.app/api/pin/?username=openwrt&repo=openwrt&show_owner=true"/></a></p>              </div>            </details><details yellow><summary> lean大的项目 </summary>              <div class='content'>              <p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/coolsnowwolf/lede"><img src="https://github-readme-stats.vercel.app/api/pin/?username=coolsnowwolf&repo=lede&show_owner=true"/></a></p>              </div>            </details><details yellow><summary> P3TERX大佬的Actions-OpenWrt项目 </summary>              <div class='content'>              <p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/P3TERX/Actions-OpenWrt"><img src="https://github-readme-stats.vercel.app/api/pin/?username=P3TERX&repo=Actions-OpenWrt&show_owner=true"/></a></p>              </div>            </details><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>之前不是在树莓派里装了raspberryPi官方的系统吗，就是类似于debian的一个系统，然后我不想让它吃灰，就先后安装了花生壳搞内网穿透、AdGuardHome来当家庭路由器的DNS服务器，拦截一下辣鸡流量、frp内网穿透、aria2下载器，但是还是不满足的我一下狠心，把TF卡给格式化了，寻找起了Openwrt的镜像～～～</p><h3 id="0x01-镜像选择"><a href="#0x01-镜像选择" class="headerlink" title="0x01 镜像选择"></a>0x01 镜像选择</h3><div class="note info modern"><p>折腾无线设备、软路由就找<a href="https://www.right.com.cn/forum/index.php">恩山论坛</a></p></div><p>我一开始想的就是在论坛里面找，可是当我搜索树莓派3b之后，发现并没有多少结果<del>4代出来之后3代就没排面了是不？</del></p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/eslt.webp" alt="eslt" style="zoom:67%;" /></p><p>唯一一个看起来不错的帖子结果要钱，而且看到评论说服了一次钱拿到链接后还要继续付费去买他的镜像，啊这！？<del>白嫖的我忍受不了</del>，溜了溜了。</p><p>然后就在github里面找，百度搜索、咕噜咕噜，最后找到了<a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=406062&amp;highlight=%CA%F7%DD%AE%C5%C9">这个项目</a>，这个大佬维护了树莓派1～4固件、x86_64平台、竞斗云项目，而且所有的固件都有三个版本，为不同需求的折腾爱好者们选择，多么贴心。顺着他的介绍我翻到了下载的链接。</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/links.webp" alt="links"></p><p>这个地方其实我也纠结了半天，一开始我并没有注意到这三者的区别，这里我不厌其烦的<del>(bushi)</del>介绍一下吧，详细吧：</p><div class="table-container"><table><thead><tr><th>Lean</th><th>Lean版固件使用Lean大源码编译，<strong>运行稳定</strong>，但对于树莓派1~4来说，USB无线网卡驱动支持较差，故固件内未集成除板载无线网卡之外的其他驱动，如确实需要无线网卡驱动，需要自行使用opkg安装相应驱动，<strong>如果你仅用作旁路由使用，建议使用此版；</strong></th></tr></thead><tbody><tr><td>Office</td><td>Offical版固件使用官方Snapshot源码+官方LuCI19.07源码编译，源码处于<strong>高度活跃开发状态</strong>，固件有时可能会因源码问题编译失败，无线网卡驱动支持性较好，固件内已内置大部分USB无线网卡驱动，无需另外安装，在Offical版固件的基础上，添加了大多数Lean版源码中的插件，但插件数量少于Lean版(未集成进Offical固件的Lean版插件即为不支持)，对官方源的兼容性较好，<strong>如果你有无线网卡需求，并有从软件源中安装软件包的需求，可以考虑使用此版；</strong></td></tr><tr><td>Project</td><td>Project版固件使用Project-OpenWrt源码18.06-kernel5.4分支编译，源码现处于<strong>测试阶段</strong>，<strong>稳定性介于以上两者之间</strong>。LuCI使用Lean版LuCI源码编译，LuCI体验与Lean版固件无异。无线网卡驱动支持性较好，固件内已内置大部分USB无线网卡驱动，无需另外安装，插件齐全(与Lean版源码相同)，<strong>如果你有无线网卡需求，并且习惯使用LuCI18.06，可以考虑使用此版；</strong></td></tr></tbody></table></div><p>我选择了lean版本，谁让我是小白呢，点击<a href="https://github.com/SuLingGG/OpenWrt-Rpi/actions?query=workflow%3A%22Build+Raspberry+Pi+3+Lean%27s+OpenWrt%22">Github</a>/<a href="https://hub.fastgit.org/SuLingGG/OpenWrt-Rpi/actions?query=workflow%3A%22Build+Raspberry+Pi+3+Lean%27s+OpenWrt%22">FastGit</a>，进入眼帘的是github action的部署页面，点击最上面的一个（也就是最新的）进入详情页面：<img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/action.webp" alt="action"></p><p>看到没，人家自动上传到了网盘里，我当时在这里兜兜转转找了半天不知道在哪里下载，仔细看了一下作者的介绍才发现他是每日凌晨2点的时候自动拉取上游项目的PR，然后用github action编译然后上传到牛奶云和google drive里（看人家薅微软多么流畅自然）。</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/ul.webp" alt="ul"></p><p>进入咕噜咕噜盘之后就寻找自己设备的cpu型号的文件夹，我是bcm2708/bcm2710，找到最新的，然后会看到文件夹下有一大堆文件，注意，这里又有坑了：</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/dfiles.webp" alt="dfiles"  /></p><ul><li><p>固件文件名中带有factory字样的文件为安装固件，固件文件名中带有sysupgrade字样的文件为升级固件。固件文件名中带有ext4字样的文件为搭载ext4文件系统固件，ext4格式的固件更适合熟悉Linux系统的用户使用，可以比较方便地调整ext4分区的大小；</p></li><li><p>固件文件名中带有squashfs字样的文件为搭载squashfs文件系统固件，而squashfs格式的固件适用于“不折腾”的用户，其优点是可以比较方便地进行系统还原（控制面板-系统-备份/升级），哪怕你一不小心玩坏固件，只要还能进入控制面板，就可以很方便地进行“系统还原操作”。以下安装和升级步骤仅适用于树莓派，竞斗云或x86_64设备请按各自原有步骤进行安装/升级操作。</p></li></ul><h3 id="0x02-安装和配置"><a href="#0x02-安装和配置" class="headerlink" title="0x02 安装和配置"></a>0x02 安装和配置</h3><p>选好了镜像咱们就把它下载下来呗，找到factory和你想要的格式的镜像下载到本地，我们会得到一个<strong>img.gz</strong>格式的文件，然后解压它，就是<strong>img</strong>镜像文件啦，使用烧录刻盘工具，这里我用的是<a href="https://www.balena.io/etcher/"><strong>BlenaEtcher</strong></a>,windows下<a href="http://rufus.ie/zh/"><strong>rufus</strong></a>也挺不错的，推荐！！！</p><p>刻好盘后有个小细节要注意，由于是此系统的第一次上电开机，不按照推荐做可能会翻车（无法连接opebwrt的wifi或者根本找不到wifi之类的玄学问题）</p><div class="tabs" id="初次开机"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#初次开机-1">方式一</button></li><li class="tab"><button type="button" data-href="#初次开机-2">方式二</button></li><li class="tab"><button type="button" data-href="#初次开机-3">提示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="初次开机-1"><p><strong>将固件刷入TF卡，断开树莓派上的所有的网线连接，将TF卡输入树莓派上电开机，稍等30喵你将可以搜索到一个名为Openwt的wifi热点，连接它，浏览器输入192.168.1.1即可进入管理界面，默认用户名为root、密码为password。</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="初次开机-2"><p><strong>将固件刷入SD卡，将SD卡插入树莓派通电开机，使用网线连接树莓派和电脑，当电脑提示有线网络已连接后，在浏览器输入192.168.1.1进入管理页面</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="初次开机-3"><p><strong>1、首次开机时，请不要将树莓派直接通过网线与路由器或光猫相连。因为树莓派默认的Lan口IP192.168.1.1很可能会与路由器或光猫的IP冲突，导致输入地址后进入路由器或光猫的控制面板。</strong></p><p><strong>2、当使用“方式二”首次连接树莓派时，无需在电脑上进行静态IP设置。</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>然后我们就可以看到我们美腻的界面了(这个图是我美化了的)：</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/luciman.webp" alt="luciman"></p><p>输入密码后即可进入，由于树莓派只有一个百兆网口，和一个板载无线网卡，我们需要把有限网口设为wan口，无线网卡当成lan口，大学教的诚不欺我<del>(p，早忘记了)</del>,我们点击网络—&gt;接口，找到LAN点击修改，它的初始协议是静态IP，我们要把它改成DHCP，选好后点击切换协议，保存&amp;应用就设置好了。</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/lan.webp" alt="lan"></p><p>页面应该会不停的转，其实已经和它断开连接了，这个时候我们给他插上网线，然后进入路由器后台就能看到它的IP啦，浏览器输入后就可以访问后台了，进行下一步操作。</p><h3 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h3><p>欲知功能如何，请听下回分析<del>（水文）</del></p>]]></content>
      
      
      <categories>
          
          <category> 折腾日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> openwrt </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> 软路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo优化之整合hpp和GA实现全web页面的操作</title>
      <link href="/post/73dad33a.html"/>
      <url>/post/73dad33a.html</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>测试测试，这是hpp发布的第一篇文章ヾ(≧∇≦*)ゝ<br>        随着这一条消息的发出，代表我已经正式折腾成功<del>自己解说我自己</del>，咳咳，没错这篇文章就是记录我是如何实现hpp+github pages实现全web页面端对博客进行操作的，是不是很方便？那就接着往下看吧～<img src="https://cdn.jsdelivr.net/gh/2x-ercha/twikoo-magic@master/image/bilibili2233/6.png" alt=""><br>  <div class="note warning modern"><p>全文内容仅代表个人观点，不杠不怼，不接受反驳</p></div></p><h3 id="0x01-Github-Action自动化部署"><a href="#0x01-Github-Action自动化部署" class="headerlink" title="0x01 Github Action自动化部署"></a>0x01 Github Action自动化部署</h3>  <div class="note info modern"><p>这部分其实店长讲的很详细了，大家也可以参考他的文章进行操作</p></div><pre><code>      首先声明，我只是按部就班的操作，但是我这里做出一点补充，就是如果大家只是简单的三端部署还是挺简单的，直接按照这样写就完事：</code></pre>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> </span><br><span class="line">      <span class="attr">gitHub:</span> <span class="string">https://[Github_Name]:[Github_Token]@github.com/[UserName]/[.github.io_repoName].git,main</span></span><br><span class="line">      <span class="attr">gitee:</span> <span class="string">https://[Gitee_Name]:[Gitee_Token]@gitee.com/[UserName]/[repo_name].git,master</span></span><br><span class="line">      <span class="attr">coding:</span> <span class="string">https://[Coding_Token_Name]:[Coding_Token]@e.coding.net/[Username]/[Project_Name]/[repo_name].git,master</span></span><br></pre></td></tr></table></figure><p>  为了避免大家看着云里雾里，我放上我的截图以供参考（就是怕你们不知道该写什么）<img src="https://cdn.jsdelivr.net/gh/2x-ercha/twikoo-magic@master/image/bilibili2233/12.png" alt=""><br>  <img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/deploy_1.webp" alt="deploy_1"><br>        好像码的有点多，哎哟，将就着看吧<br>        然后<strong>重点来了</strong>，对于有服务器<del>（钱）</del>的小伙伴来说，github pages可能已经无法满足自己<del>（消费)</del>的需求，同时还想往服务器部署的，就需要在repo加一个字段：</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cloudserver:</span> <span class="string">user@ip:/路径</span></span><br></pre></td></tr></table></figure><p>  但是这里有个坑，由于hexo-deployer-git是默认使用的ssh传输方式，也就是利用默认的22号端口进行数据交互，但是我前不久改了端口号，导致需要指定端口号进行传输，这种方式就不起效了，我看了一下hexo的官方文档的部署这一块，发现了另一个传输模块：hexo-deployer-rsync<br>  <img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/rsync.webp" alt="rsync"><br>        官方介绍得很详细，什么地方填什么，这里我就不再贴我的图了，<br>  <img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/deploy_2.webp" alt="deploy_2"><br>  才怪，能多水一点<img src="https://cdn.jsdelivr.net/gh/2x-ercha/twikoo-magic@master/image/bilibili2233/8.png" alt=""></p><h3 id="0x02-Hexoplusplus"><a href="#0x02-Hexoplusplus" class="headerlink" title="0x02 Hexoplusplus"></a>0x02 Hexoplusplus</h3><p>  <img src="https://cdn.jsdelivr.net/gh/2x-ercha/twikoo-magic@master/image/huaji/huaji45.gif" alt=""></p><p>这个可以算是非常方便的工具了，教程也有现成的，<a href="https://hexoplusplus.js.org/">传送门</a>,那么这里我就说说我的使用感受吧，首先肯定要写篇文章试试水嘛，就有了这样一篇无标题的文章：<br>  <img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/untitled.webp" alt="untitled"><br>        因为在这里写新文章是没有front_matter的，所以也就没有标题，然鹅我忘了，误以为文件名就是标题，结果第一篇文章就闹了笑话，(手动滑稽.jpg)<br>  <img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/hpp.webp" alt="hpp"><br>       然后编辑区是类似windows记事本那种纯文本编辑区，没有markdown格式美化，也只能进行简单的预览，剪辑那个眼睛👀即可，图片是别想看到的，说到这里还是vscode和typora写文章香，丰富的富文本编辑区，代码美化，markdown渲染预览等等…</p><h3 id="0x03-欲扬先抑"><a href="#0x03-欲扬先抑" class="headerlink" title="0x03 欲扬先抑"></a>0x03 欲扬先抑</h3><p>说了一些不太好的感觉体验，接下来说说我觉得比较好几点<br>        首先，UI整体还是不错的，一进来就有种主人翁的感觉，是真正的觉得进入了管理博客的场所，要做点什么的感觉油然而生，其次，功能还是挺丰富的，文章管理、图片管理、叨叨、还有artitalk（不是为了抢生意哦～）可以便捷的管理博客的各类资源文件，然后我们要明确hpp的功能定位，他是在不方便使用电脑的情况下给大家管理博客用的，也就是说对文章进行改动或者是临时记录点什么，比如日记和图片用这个还是非常方便的，但如果要写很详细的文章，需要用到很多种标签之类的还是推荐大家用typora或者vscode来编写，然后按那个文件型的按钮，就可以上传到这里再进行发布，毕竟写作体验很重要～<br>        最后还是感谢各位开发者大大，感谢你们提供的这个平台方便我们广大的hexo爱好者来折腾，也希望你们能有更多更好的作品<del>（让我白嫖）</del></p>]]></content>
      
      
      <categories>
          
          <category> 折腾日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo优化 </tag>
            
            <tag> 小插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小身材大能量之树莓派的AdGuardHome之旅</title>
      <link href="/post/50d3c86e.html"/>
      <url>/post/50d3c86e.html</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>前段时间不是在树莓派上装了个花生壳实现内网穿透吗，可以随时随地控制家里的小板子，然后我就总是觉得它能做点什么，它应该做点什么。后来在一位热心网友的介绍下，我入坑了AdGuardHome。</p><div class="note info modern"><p>想去了解一下这位热心网友可以去酷安找他@Hacamer,有很多AdGuard的规则和介绍</p></div><p>然鹅，我是参照<a href="https://blog.csdn.net/hailangnet/article/details/115446700">这篇文章</a>来完成前期的搭建，后面的配置部分是参考了别的文章。</p><p>话不多说，开始正式部分。</p><h3 id="0x01-下载-amp-amp-安装"><a href="#0x01-下载-amp-amp-安装" class="headerlink" title="0x01 下载&amp;&amp;安装"></a>0x01 下载&amp;&amp;安装</h3><p>当然主角还是我们的树莓派3b了，然后在<a href="https://github.com/AdguardTeam/AdGuardHome/releases">AdGuardHome的github上</a>找到适合自己的二进制包，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/AdGHDL.webp" alt="AdGHDL"></p><p>由于树莓派3b是armv7架构的芯片，所以我选择这个，其实仓库里的二进制包支持的平台还挺多的，不知道自己受伤设备CPU架构的可以使用<code>lscpu</code>来查看：</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/lscpu.webp" alt="lscpu"></p><p>如果嫌弃树莓派下载速度太慢了的话呢，<del>我是不会告诉你可以使用镜像网站（hub.fastgit.org）来下载</del>可以在自己电脑上下好了传过去嘛，<del>做人要懂得变通</del>,然后我们使用<code>tar -xvzf AdGuardHome_linux_armv7.tar.gz</code>来解压这个安装包，就会得到一个同名文件夹，然后<code>cd AdGuardHome_linux_armv7</code>进入到这个文件夹中，使用<code>./AdGuardHome -s install</code>来安装程序，安装成功后会提示xxxxx installed successfully的字样，并且直接告诉你后台管理页面的地址和端口，一般的，如果你连接了显示器，就可以用localhost:3000登陆后台，要么ssh用内网ip:3000来登陆。</p><h3 id="0x02-配置"><a href="#0x02-配置" class="headerlink" title="0x02 配置"></a>0x02 配置</h3><p>​        第一次进入到管理页面，它会提示你设置管理密码，并且告诉你各种设备加入AdGuardHome的守护范围之内该怎么配置：</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/AdGHSetUp.webp" alt="AdGHSetUp"></p><p>这样看来对新手<del>我本人就是</del>还是非常友好的嘛。</p><p>因为我的树莓派从此就不断电了，而且在每一个设备上单独弄AdGuard有点麻烦，直接设置路由器一劳永逸多好呢，直接拦截整个局域网的流量，其实也比较简单，进入路由的管理后台，设置DNS为树莓派的IP地址即可，保存设置后重启路由器，你的树莓派就成了整个家庭局域网的保护伞了，阻挡各种垃圾流量义不容辞。</p><h4 id="1、常规配置"><a href="#1、常规配置" class="headerlink" title="1、常规配置"></a>1、常规配置</h4><p>常规配置就看我的操作撒～</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/GS_1.webp" alt="GS_1"></p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/GS_2.webp" alt="GS_2"></p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/GS_3.webp" alt="GS_3"></p><ul><li>过滤器更新间隔：DNS 过滤清单默认更新间隔，一般为 3 天 - 7 天</li><li>使用 AdGuard “浏览安全” 网页服务：作用与 Chrome 网页安全性检查类似，开启后，当用户访问存在潜在威胁的网站时，AdGuard 会主动拦截并弹出提示</li><li>使用 AdGuard “家长控制” 服务：如果家中有尚未成年的孩子，建议开启，避免访问不良网站</li><li>强制安全搜索：隐藏 Bing、Google、Yandex、YouTube 网站上 NSFW 等不适宜的内容</li><li>查询记录保留时间：AdGuard Home 服务端采用 Sqlite 文件数据库存储日志，长时间保留可能会降低运行速度，同时占用大量的储存空间，家庭用户一般保留 24 小时 - 7 天即可</li><li>统计数据保留时间：用于仪表盘的数据展示，一般保留 24 小时 - 7 天即可</li></ul><h4 id="2、DNS设置（重点）"><a href="#2、DNS设置（重点）" class="headerlink" title="2、DNS设置（重点）"></a>2、DNS设置（重点）</h4><p>接下来配置AdGuardHome的上游DNS服务器，这里国内比较推荐的是<a href="https://dns.alidns.com/dns-query">阿里云</a>、<a href="https://doh.360.cn/dns-query">360</a>,在如图所示的输入框中填好即可</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/dnsquery.webp" alt="dnsquery"></p><ul><li>上游 DNS 服务器：AdGuard Home 的上游 DNS 服务器，可参考下方推荐列表，一般保留 1 - 2 个即可。AdGuard Home 除了可以作为广告过滤网关，如果设置了纯净 DNS 后，还可以避免运营商的 DNS 劫持</li><li>BootStrap DNS 服务器地址：作为 DoH / DoT DNS 的前置 DNS 解析器，可参考下方推荐列表<br>查询方式、速度限制、EDNS、DNSSEC、拦截模式、DNS 缓存设置、访问设置可根据需要进行调整，一般保持默认设置即可</li></ul><p><strong>Tips:不同地区连接至 DNS 服务器的速度各有差异，各位可以通过 Ping 测速的方式寻找当地连接延迟最低的 DNS 服务器。更多 DNS 服务器可以在 AdGuard 文档中找到。</strong><br><details yellow><summary> DNS服务器推荐 </summary>              <div class='content'>              <ol><li><p>阿里:</p><ul><li>IPv4 DNS：223.5.5.5</li><li>IPv6 DNS：2400:3200:baba::1</li><li>DoH： <a href="https://dns.alidns.com/dns-query">https://dns.alidns.com/dns-query</a> </li></ul></li><li><p>DNSPod:</p><ul><li>IPv4 DNS：119.29.29.29</li><li>DoH： <a href="https://doh.pub/dns-query">https://doh.pub/dns-query</a> </li></ul></li><li><p>114:</p><ul><li>IPv4 DNS：114.114.114.114</li></ul></li><li><p>Google:</p><ul><li>IPv4 DNS：8.8.8.8</li><li>IPv6 DNS：2001:4860:4860::8888</li><li>DoH： <a href="https://dns.google/dns-query">https://dns.google/dns-query</a> </li></ul></li><li><p>Cloudflare:</p><ul><li>IPv4 DNS：1.1.1.1</li><li>IPv6 DNS：2606:4700:4700::1111</li><li>DoH： <a href="https://dns.cloudflare.com/dns-query">https://dns.cloudflare.com/dns-query</a> </li></ul></li></ol>              </div>            </details></p><p>设置好了这些都还没完呢，为了更好的发挥它的效果，还有个很重要的功能就是DNS封锁，这里我也列举几个供大家参考：<br><div class="note warning modern"><p>这个DNS封锁规则请大家按需所取，可能有的会<del>很慢</del>不适用</p></div><br><details yellow><summary> DNS封锁推荐 </summary>              <div class='content'>              <ul><li>AdGuard DNS Filter： <a href="https://hacamer.coding.net/p/lite/d/AdBlock-Rules-Mirror/git/raw/master/AdGuard-Simplified-Domain-Names-Filter.txt">https://hacamer.coding.net/p/lite/d/AdBlock-Rules-Mirror/git/raw/master/AdGuard-Simplified-Domain-Names-Filter.txt</a> </li><li><del>EasyList： <a href="https://easylist-downloads.adblockplus.org/easylist.txt">https://easylist-downloads.adblockplus.org/easylist.txt</a></del></li><li>EasyList China： <a href="https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/EasyList_China.txt">https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/EasyList_China.txt</a></li><li>EasyPrivacy： <a href="https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/EasyPrivacy.txt">https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/EasyPrivacy.txt</a></li><li>Halflife 规则： <a href="https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/HalfLife.txt">https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/HalfLife.txt</a></li><li>Xinggsf 乘风过滤： <a href="https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/Xinggsf_rule.txt">https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/Xinggsf_rule.txt</a></li><li>Xinggsf 乘风视频过滤： <a href="https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/Xinggsf_mv.txt">https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/Xinggsf_mv.txt</a></li><li>MalwareDomainList： <a href="https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/Malware_hosts.txt">https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/Malware_hosts.txt</a></li><li>Adblock Warning Removal List： <a href="https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/antiadblockfilters.txt">https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/antiadblockfilters.txt</a></li><li>Anti-AD： <a href="https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/Anti_AD_Easylist.txt">https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/Anti_AD_Easylist.txt</a></li><li>Fanboy’s Annoyances List： <a href="https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/fanboy-annoyance.txt">https://cdn.jsdelivr.net/gh/Silentely/AdBlock-Acceleration/fanboy-annoyance.txt</a></li></ul>              </div>            </details></p><p><del>夹点私货</del>这里我们选择一位大佬的规则<br><details yellow><summary> 以下内容By 酷安@冷莫 </summary>              <div class='content'>              <ul><li><a href="http://file.trli.club/dns/ad-hosts.txt">http://file.trli.club/dns/ad-hosts.txt</a> (搭配白名单使用)</li><li><a href="http://file.trli.club/dns/whitelist.txt">http://file.trli.club/dns/whitelist.txt</a> (白名单,放进允许清单)</li><li><a href="http://file.trli.club/dns/ad-adblock.txt">http://file.trli.club/dns/ad-adblock.txt</a> (与 <a href="http://file.trli.club/dns/ad-hosts.txt">http://file.trli.club/dns/ad-hosts.txt</a> 任一即可,但都要搭配白名单)</li></ul>              </div>            </details></p><p>以浏览国内网站为主的用户可以使用 anti-AD + Halflife 过滤规则，如有浏览国外网站的需要，可以根据需要添加 AdGuard DNS Filter、Fanboy’s Annoyances List 等规则。不同规则之间会存在重叠的情况，可以通过 AdGuard Home 的拦截日志分析哪些规则的使用频率最高，哪些规则拦截频率最低，再加以取舍。</p><h3 id="0x02-效果"><a href="#0x02-效果" class="headerlink" title="0x02 效果"></a>0x02 效果</h3><p>最后给大家看看我使用一下午的效果，现在写这篇文章到这里是晚上⏰11:37：</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/show_1.webp" alt="show_1"></p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/show_2.webp" alt="show_2"></p><p>啊这，，，某宝和某团有点恐怖啊～</p>]]></content>
      
      
      <categories>
          
          <category> 折腾日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 软件推荐 </tag>
            
            <tag> AdGuardHome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网穿透之玩转花生壳-入门篇</title>
      <link href="/post/2788188b.html"/>
      <url>/post/2788188b.html</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前景一提"><a href="#0x00-前景一提" class="headerlink" title="0x00 前景一提"></a>0x00 前景一提</h3><p>家里闲置了一个树莓派好久，一直想拿它做点什么，又一直不知道能做些什么，其实关于它的教程网上一直有很多，特别是某小破站，这里我推荐一下树莓派的最佳项目，感兴趣的小伙伴们可以自行观看：</p><center><div class="tag link"><a class="link-card" title="2019年最棒的十大树莓派项目" href="https://www.bilibili.com/video/BV1ot411P75G?from=search&seid=13110630399688723319"><div class="left"><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/PiProj.ico"/></div><div class="right"><p class="text">2019年最棒的十大树莓派项目</p><p class="url">https://www.bilibili.com/video/BV1ot411P75G?from=search&seid=13110630399688723319</p></div></a></div></center><p>后来我知道可以将内网IP映射到公网我才突然想起啦家里还有个吃灰的小板子，话不多说，咱们立马开动。</p><h3 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h3><p>首先，我们要有一块树莓派，这里我用的是树莓派3b，<del>老伙伴了</del>，它是这样子的: <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg3.mukewang.com%2F5bf1507c0001c84e04500302.jpg&refer=http%3A%2F%2Fimg3.mukewang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1628091543&t=419d7a50b41c411a81ad5b34fc971925" alt="pi" style="zoom:60%;" /></p><p>我们先进入<a href="https://www.raspberrypi.org/software/raspberry-pi-desktop/">树莓派官网</a>找对应的系统下载到电脑上，然后找来一张TF卡，插入读卡器后连接到电脑，可以利用主流的烧录镜像的软件把固件烧录到TF卡上，最原始的就是利用命令行工具啦，最帅<del>bushi</del>，由于我用的MacOS是类Unix系统，可以直接用大部分linux的命令，当然用linux/unix系统的童鞋也可以参考我的<a href="https://www.runoob.com/linux/linux-comm-dd.html">dd命令</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=~/Downloads/pi.os of=/dev/mmcblk0 status=progress bs=4M</span><br></pre></td></tr></table></figure><p>烧录好之后就可以把TF卡插进树莓派背部的小卡槽啦，接上电源，插上各种外设，通电～过一会儿就可以看到画面了。</p><p><strong>Tips：</strong>如果没有外接显示器的同学可以直接用ssh连接，前提是得开启wifi和ssh，这一节我会在文章最后的补充中专门介绍。</p><p>话接上文，开启屏幕后，我们先打开屏幕右上角的wifi图标，选择好输入密码后就联网了，然后我们打开终端，先输入<code>sudo apt update &amp;&amp; sudo apt upgrade</code>进行常规的系统升级，然后点击屏幕左上角的树莓派logo，点击<strong>首选项</strong>—&gt;<strong>Raspberry Pi Configuration</strong>，然后点击<strong>Interfaces</strong>选项卡，就能看到SSH啦，勾选Enable就可以了。此时它已经不需要所有外设了，仅仅只要一根电源线给它供电就行。</p><h3 id="0x02-步入正轨"><a href="#0x02-步入正轨" class="headerlink" title="0x02 步入正轨"></a>0x02 步入正轨</h3><h4 id="1、安装花生壳"><a href="#1、安装花生壳" class="headerlink" title="1、安装花生壳"></a>1、安装花生壳</h4><p>我们先去<a href="https://hsk.oray.com/download/">花生壳</a>找符合自己树莓派系统的安装包，这里我的树莓派是32位系统，就下载这个：<br><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed/MyBlog/hsk.png" alt="hsk" style="zoom:60%;" /></p><p>然后就会得到一个deb文件，这是debian系linux的标准安装包，可是这个在我们电脑上啊，怎么把它传到树莓派上呢，这时就可以使用<a href="https://www.runoob.com/linux/linux-comm-scp.html">scp命令</a>，我的如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~/Downloads/pi.deb pi@192.168.**.**:/home/pi/Downloads/</span><br></pre></td></tr></table></figure><p>Tips：@后面跟的是你的树莓派的IP地址哦</p><p>这时再来看我们树莓派位文件目录，Downloads下就有我们传过去的pi.deb啦:</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/pideb.png" alt="pideb"></p><p>接着输入<code>sudo depkg -i pi.deb</code>等待安装完毕即可。安装完毕后就会显示设备账户初始信息，包括SN码和初始密码，以及远程管理网址，当然之后也可以通过命令<code>sudo phddns status</code>来查看：</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/phddns.png" alt="phddns"></p><h4 id="2、登陆配置"><a href="#2、登陆配置" class="headerlink" title="2、登陆配置"></a>2、登陆配置</h4><p>在浏览器输入网址<a href="http://b.oray.com进入远程管理接口，输入对应的SN码和初始密码admin就能进去啦，之后就按照要求进行绑定手机，重设密码之类的操作，这里我就不多说了。">http://b.oray.com进入远程管理接口，输入对应的SN码和初始密码admin就能进去啦，之后就按照要求进行绑定手机，重设密码之类的操作，这里我就不多说了。</a></p><p>进入管理页面后我们点击<strong>内网穿透</strong>—&gt;<strong>添加映射</strong>，访问地址就填写自己树莓派的IP地址，端口就是ssh默认的22端口，点击保存，等页面运行一下，咱们的树莓派就可以用公网IP进行通信啦！花生壳会给我们分配一个公网域名、公网IP和一个端口，我们可以在非局域网的环境中指挥我们的树莓派工作了。</p><p>点击诊断，就可以查看公网IP和端口了。</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/zhenduan.png" alt="zhenduan" style="zoom:80%;" /></p><p>当然我们也可以在手机上下载花生壳App来管理和查看我们的设备工作情况。怎么样，是不是很方便呢？</p><p>从此树莓派不断电～～～我们可以用它公网IP和映射的端口来操作它了。</p><h3 id="0x03-补充"><a href="#0x03-补充" class="headerlink" title="0x03 补充"></a>0x03 补充</h3><h4 id="1、WiFi配置"><a href="#1、WiFi配置" class="headerlink" title="1、WiFi配置"></a>1、WiFi配置</h4><p>用户可以在未启动树莓派的状态下单独更改<code>/boot/wap_supplicant.conf</code>文件配置WiFi的SSID和密码，这样树莓派在通电启动后自行读取wpa_supplicant.conf配置文件连接WiFi设备。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">country=CN</span></span><br><span class="line"><span class="string">ctrl_interface=DIR=/var/run/wpa_supplicant</span> <span class="string">GROUP=netdev</span></span><br><span class="line"><span class="string">update_config=1</span></span><br><span class="line"></span><br><span class="line"><span class="string">network=&#123;</span></span><br><span class="line">  <span class="string">ssid=&quot;你的WiFi名&quot;</span></span><br><span class="line">  <span class="string">psk=&quot;你的WiFi密码&quot;</span></span><br><span class="line">  <span class="string">key_mgmt=WPA-PSK</span></span><br><span class="line">  <span class="string">priority=1</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">network=&#123;</span></span><br><span class="line"><span class="string">ssid=&quot;你的WiFi名&quot;</span></span><br><span class="line">  <span class="string">psk=&quot;你的WiFi密码&quot;</span></span><br><span class="line">  <span class="string">key_mgmt=WPA-PSK</span></span><br><span class="line">  <span class="string">priority=2</span></span><br><span class="line">  <span class="string">scan_ssid=1</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>说明一下</strong>：</p><ul><li>ssid就是网络的SSID</li><li>psk就是密码</li><li>priority是连接的优先级买数字越大优先级越高（不可以取负数）</li><li>scan_ssid连接隐藏的WiFi时需要指定该值为1</li></ul><p>如果你的WiFi没有密码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">network=&#123;</span></span><br><span class="line"><span class="string">ssid=&quot;你的WiFi名&quot;</span></span><br><span class="line"><span class="string">key_mgmt=NONE</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>如果你的WiFi使用WEP加密：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">network=&#123;</span></span><br><span class="line"><span class="string">ssid=&quot;你的WiFi名&quot;</span></span><br><span class="line"><span class="string">key_mgmt=NONE</span></span><br><span class="line"><span class="string">wep_key0=&quot;你的WiFi密码&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>如果你的WiFi使用WPA/WPA2加密：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">network&#123;</span></span><br><span class="line"><span class="string">ssid=&quot;你的无线网络名称（ssid）&quot;</span></span><br><span class="line"><span class="string">key_mgmt=WPA-PSK</span></span><br><span class="line"><span class="string">psk=&quot;你的wifi密码&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2、开启ssh服务"><a href="#2、开启ssh服务" class="headerlink" title="2、开启ssh服务"></a>2、开启ssh服务</h4><p>和配置WiFi的方式相似，我们可以直接在TF卡的根目录下新建一个SSH文件（无后缀），这里网上其实还有很多介绍的教程，但是根据情况哈，这里我们是配好了网，没有显示器的情况下来开启ssh，貌似只有这一种方法了。不过也可能有疏漏，欢迎各路大佬来补充和指正～</p>]]></content>
      
      
      <categories>
          
          <category> 折腾日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 软件推荐 </tag>
            
            <tag> 折腾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于基站定位的商圈分析</title>
      <link href="/post/52f4aab5.html"/>
      <url>/post/52f4aab5.html</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-任务背景"><a href="#0x00-任务背景" class="headerlink" title="0x00 任务背景"></a>0x00 任务背景</h3><p>随着个人手机终端的普及，手机移动网络也基本实现了城乡空间区域的全覆盖。根据手机信号在真实地理空间上的覆盖情况，将手机用户时间序列的手机定位数据，映射至现实的地理空间位置，即可完整、客观地还原出手机用户的现实活动轨迹，从而挖掘得到人口空间分布与活动联系的特征信息。<br>        商圈是现代市场中企业市场活动的空间，同时也是商品和服务享用者的区域。商圈划分的目的之一是研究潜在的顾客分布，以制定适宜的商业对策。</p><h3 id="0x01-数据挖掘目标"><a href="#0x01-数据挖掘目标" class="headerlink" title="0x01 数据挖掘目标"></a>0x01 数据挖掘目标</h3><ol><li>对用户的历史定位数据，采用数据挖掘技术，对基站进行分群。</li><li>对不同的商圈分群进行特征分析，比较不同商圈类别的价值，选择合适的区域进行运营商的促销活动。</li></ol><h3 id="0x02-语句探索与预处理"><a href="#0x02-语句探索与预处理" class="headerlink" title="0x02 语句探索与预处理"></a>0x02 语句探索与预处理</h3><p>数据挖掘的目标主要是为了找出高价值的商业圈，高价值的商业圈具有人流大，人均停留时间长的特点。但是工作区在工作日也有人流大，人流时间长的特点，经过分析，选取工作日人均停留时间，周末人均停留时间，凌晨人均停留时间，日均人流能量几个特征进行建模和分析。</p><p>首先观察一下原始数据，先选取了前十条观测一下：</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed/MyBlog/image-20210701101506924.png" alt="image-20210701101506924"></p><p>可以发现各属性的量级差异比较大，处理不太方便，需要标准化处理一下，数据的标准化是将数据按比例缩放，把他们落入一个小的特定的区间，便于不同单位或量级的指标能进行比较和加权。常用的方法有「离差标准化」、「log函数变换」、「atan函数转换」、「z-score标准化」、「归一化方法」等。</p><p>这里我们可以采用离差标准化来处理数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数初始化</span></span><br><span class="line"><span class="comment"># 原始数据文件</span></span><br><span class="line">ori_data = <span class="string">&#x27;data/business_circle.xls&#x27;</span></span><br><span class="line"><span class="comment"># 标准化文件传输出路径</span></span><br><span class="line">standardizedfile = <span class="string">&#x27;data/standardized.xls&#x27;</span></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">data = pd.read_excel(ori_data, index_col=<span class="string">u&#x27;基站编号&#x27;</span>)</span><br><span class="line"><span class="comment"># 离差标准化</span></span><br><span class="line">data = (data - data.<span class="built_in">min</span>()) / (data.<span class="built_in">max</span>() - data.<span class="built_in">min</span>())</span><br><span class="line">data = data.reset_index()</span><br><span class="line"><span class="comment"># 保存结果</span></span><br><span class="line">data.to_excel(standardizedfile, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed/MyBlog/image-20210701101535597.png" alt="image-20210701101535597"></p><p>可以看出数据已经被归化在[0,1]这个区间内，降低了原始数据的差异对结果的影响。</p><h3 id="0x03-模型构建与评价"><a href="#0x03-模型构建与评价" class="headerlink" title="0x03 模型构建与评价"></a>0x03 模型构建与评价</h3><p>这里可以采用层次聚类的方法对数据集进行层次分解，直到满足某种条件。在已经得到距离值之后，元素间可以被联系起来。通过分离和融合可以构建一个结构。传统上，表示的方法是树形数据结构，层次聚类算法，要么是自底向上聚集型的，即从叶子节点开始，最终汇聚到根节点；要么是自顶向下分裂型的，即从根节点开始，递归的向下分裂。最终去查看每一类商圈的特征。</p><p>但是首先要知道分成多少类比较合适，即得出k值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.cluster.hierarchy <span class="keyword">import</span> linkage, dandrogram</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数初始化</span></span><br><span class="line">standardizedfile = <span class="string">&#x27;data/standardized.xls&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">data = pd.read_excel(standardizedfile, index_col=<span class="string">u&#x27;基站编号&#x27;</span>)</span><br><span class="line"><span class="comment"># 谱系聚类图</span></span><br><span class="line">Z = linkage(data, method=<span class="string">&#x27;ward&#x27;</span>, metric=<span class="string">&#x27;euclidean&#x27;</span>)</span><br><span class="line">P = dendrogram(Z, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">&#x27;output/px.png&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后观察输出的图片：</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed/MyBlog/image-20210701101601434.png" alt="image-20210701101601434"></p><p>可以看出分成了三大类，所以为后续构建模型做了准备工作。就可以构建模型了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span></span><br><span class="line">lpt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">style = [<span class="string">&#x27;ro-&#x27;</span>, <span class="string">&#x27;go-&#x27;</span>, <span class="string">&#x27;bo-&#x27;</span>]</span><br><span class="line">xlabels = [<span class="string">&#x27;Average stay time in working days&#x27;</span>, <span class="string">&#x27;Average stay time in the morning&#x27;</span>, <span class="string">&#x27;Average length of stay on weekends&#x27;</span>, <span class="string">&#x27;Average daily passenger flow&#x27;</span>]</span><br><span class="line"><span class="comment"># 聚类图文件名前缀</span></span><br><span class="line">pic_output = <span class="string">&#x27;output/pic_&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐一作图，作出不同样式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(model_training.k):</span><br><span class="line">    plt.figure()</span><br><span class="line">    <span class="comment"># 提取每一类</span></span><br><span class="line">    tmp = model_training.r[model_training.r[<span class="string">u&#x27;聚类类别&#x27;</span>] == i].iloc[:, :<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)):</span><br><span class="line">        plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>), tmp.iloc[j], style[i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 坐标标签</span></span><br><span class="line">    plt.xticks(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>), xlabels, rotation=<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 调整计数从1开始</span></span><br><span class="line">    plt.title(<span class="string">&#x27;Business district category%s&#x27;</span> % (i + <span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 调整底部</span></span><br><span class="line">    plt.subplots_adjust(bottom=<span class="number">0.15</span>)</span><br><span class="line">    <span class="comment"># 输出图片</span></span><br><span class="line">    plt.savefig(<span class="string">u&#x27;%s%s.png&#x27;</span> % (pic_output, i + <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>然后就可以查看output文件夹的图片了：</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed/MyBlog/image-20210701101700587.png" alt="image-20210701101700587"></p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed/MyBlog/image-20210701101716917.png" alt="image-20210701101716917"></p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed/MyBlog/image-20210701101732554.png" alt="image-20210701101732554"></p><p>注：由于中文显示问题，我把标签都改成英文了，从左到右依次是：「工作日人均停留时间」、「凌晨人均停留时间」、「周末人均停留时间」、「日均人流量」，图的标题是商圈类别1、2、3。</p><p>从这三张图分析可知:</p><p>-    「商圈类别1」：工作日人均停留时间、凌晨人均停留时间都很低，周末人均停留时间中等，日人均流量很高。比较符合商业区。</p><p>-    「商圈类别2」：工作日人均停留时间中等、凌晨和周末人均停留时间很长，日均人流量很低。比较符合居住区。</p><p>-    「商圈类型3」：工作日人均停留时间很长，凌晨和周末停留时间较少，日均人流量中等。比较符合办公区。</p><p>根据原始数据和这三张图的特点来选择建立商区，需要满足“停留时间”波动较小且在原始数据中的值较大。这样才会有比较好的收益。</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> python </tag>
            
            <tag> 聚类算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/post/ea4681d0.html"/>
      <url>/post/ea4681d0.html</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-为什么要研究二叉树的遍历"><a href="#0x00-为什么要研究二叉树的遍历" class="headerlink" title="0x00 为什么要研究二叉树的遍历"></a>0x00 为什么要研究二叉树的遍历</h3><p>在计算机中，遍历本身是一个线性操作。所以遍历同样具有线性结构的数组或链表，是一件轻而易举的事情。</p><p>数组的遍历如下：</p><div class="table-container"><table><thead><tr><th>9</th><th>2</th><th>3</th><th>8</th><th>4</th><th>7</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">9 --&gt; 2;</span><br><span class="line">2 --&gt; 3;</span><br><span class="line">3 --&gt; 8;</span><br><span class="line">8 --&gt; 4;</span><br><span class="line">4 --&gt; 7;</span><br></pre></td></tr></table></figure><p>链表的遍历如下,很简单，和链表的指向结构一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">6((6)) --&gt; 3((3))</span><br><span class="line">3((3)) --&gt; 4((4))</span><br><span class="line">4((4)) --&gt; 5((5))</span><br><span class="line">5((5)) --&gt; 1((1))</span><br></pre></td></tr></table></figure><p>反观二叉树，是典型的非线性数据结构，遍历时我们需要把非线性关联的节点转换成一个线性的序列。以不同的方式来遍历，得到的结果序列顺序也不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">1((1)) --&gt; 2((2))</span><br><span class="line">1((1)) --&gt; 3((3))</span><br><span class="line">2((2)) --&gt; 4((4))</span><br><span class="line">2((2)) --&gt; 5((5))</span><br><span class="line">3((3)) --&gt; 6((6))</span><br></pre></td></tr></table></figure><p>那么，二叉树有哪些遍历方式呢？</p><p>从节点的位置关系来看的话，分为四种：</p><ol><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li><li>层序遍历</li></ol><p>从更宏观的角度来讲的话，分为两大类：</p><ol><li>广度优先遍历（层序遍历）</li><li>深度优先遍历（前序遍历、中序遍历、后序遍历）</li></ol><h3 id="0x01-深度优先遍历"><a href="#0x01-深度优先遍历" class="headerlink" title="0x01 深度优先遍历"></a>0x01 深度优先遍历</h3><h4 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1.前序遍历"></a>1.前序遍历</h4><p>口诀：根左右。具体来说就是每次遍历都遵循<strong>根节点、左子树、右子树</strong>的顺序。我们来举一个栗子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">1((1)) --&gt; 2((2))</span><br><span class="line">1((1)) --&gt; 3((3))</span><br><span class="line">2((2)) --&gt; 4((4))</span><br><span class="line">2((2)) --&gt; 5((5))</span><br><span class="line">3((3)) --&gt; 6((6))</span><br></pre></td></tr></table></figure><p>这科二叉树的遍历序列可以简化成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1 --&gt; 2</span><br><span class="line">2 --&gt; 4</span><br><span class="line">4 --&gt; 5</span><br><span class="line">5 --&gt; 3</span><br><span class="line">3 --&gt; 6</span><br></pre></td></tr></table></figure><h4 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h4><p>口诀：左根右。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">1((1)) --&gt; 2((2))</span><br><span class="line">1((1)) --&gt; 3((3))</span><br><span class="line">2((2)) --&gt; 4((4))</span><br><span class="line">2((2)) --&gt; 5((5))</span><br><span class="line">3((3)) --&gt; 6((6))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">4 --&gt; 2</span><br><span class="line">2 --&gt; 5</span><br><span class="line">5 --&gt; 1</span><br><span class="line">1 --&gt; 3</span><br><span class="line">3 --&gt; 6</span><br></pre></td></tr></table></figure><h4 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3.后序遍历"></a>3.后序遍历</h4><p>口诀：左右根。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">1((1)) --&gt; 2((2))</span><br><span class="line">1((1)) --&gt; 3((3))</span><br><span class="line">2((2)) --&gt; 4((4))</span><br><span class="line">2((2)) --&gt; 5((5))</span><br><span class="line">3((3)) --&gt; 6((6))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">4 --&gt; 5</span><br><span class="line">5 --&gt; 2</span><br><span class="line">2 --&gt; 6</span><br><span class="line">6 --&gt; 3</span><br><span class="line">3 --&gt; 1</span><br></pre></td></tr></table></figure><h4 id="4-代码环节"><a href="#4-代码环节" class="headerlink" title="4.代码环节"></a>4.代码环节</h4><p>在我们熟悉了二叉树的几种遍历方式的思想后，能实现它才是最重要的，不能光说不做对吧。</p><h5 id="递归式遍历"><a href="#递归式遍历" class="headerlink" title="递归式遍历"></a>递归式遍历</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先声明一个节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">self.data = data</span><br><span class="line">    self.left = <span class="literal">None</span></span><br><span class="line">    self.right = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create_binary_tree</span>(<span class="params">input_list=[]</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构建二叉树</span></span><br><span class="line"><span class="string">    :param input_list: 输入数列</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> input_list <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(input_list) == <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    data = input_list.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    node = TreeNode(data)</span><br><span class="line">    node.left = create_binary_tree(input_list)</span><br><span class="line">    node.right = create_binary_tree(input_list)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pre_order_traversal</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    前序遍历</span></span><br><span class="line"><span class="string">    :param node: 二叉树节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(node.data)</span><br><span class="line">    pre_order_traversal(node.left)</span><br><span class="line">    pre_order_traversal(node.right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">in_order_traversal</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    中序遍历</span></span><br><span class="line"><span class="string">    :param node:二叉树节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    in_order_traversal(node.left)</span><br><span class="line">    <span class="built_in">print</span>(node.data)</span><br><span class="line">    in_order_traversal(node.right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">post_order_traversal</span>(<span class="params">node</span>):</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      后序遍历</span></span><br><span class="line"><span class="string">      :param node: 二叉树节点</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      post_order_traversal(node.left)</span><br><span class="line">      post_order_traversal(node.right)</span><br><span class="line">      <span class="built_in">print</span>(node.data)</span><br><span class="line">      <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><p>然后我输入一个测试序列来检测是否符合结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_input_list = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">10</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">8</span>, <span class="literal">None</span>, <span class="number">4</span>]</span><br><span class="line">root = create_binary_tree(my_input_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;前序遍历：&quot;</span>)</span><br><span class="line">pre_order_traversal(root)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;中序遍历：&quot;</span>)</span><br><span class="line">in_order_traversal(root)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;后序遍历&quot;</span>)</span><br><span class="line">post_order_traversal(root)</span><br></pre></td></tr></table></figure><p>在这里，二叉树的构建流程如下，需要注意的是，列表中的None代表儿子节点为空的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">3((3)) --1--&gt; 2((2))</span><br><span class="line">2((2)) --2--&gt; 9((9))</span><br><span class="line">9((9)) --3--&gt; None_1((None))</span><br><span class="line">9((9)) --4--&gt; None_2((None))</span><br><span class="line">2((2)) --5--&gt; 10((10))</span><br><span class="line">10((10)) --6--&gt; None_3((None))</span><br><span class="line">10((10)) --7--&gt; None_4((None))</span><br><span class="line">3((3)) --8--&gt; 8((8))</span><br><span class="line">8((8)) --9--&gt; None_5((None))</span><br><span class="line">8((8)) --10--&gt; 4((4))</span><br></pre></td></tr></table></figure><h5 id="非递归式遍历（栈）"><a href="#非递归式遍历（栈）" class="headerlink" title="非递归式遍历（栈）"></a>非递归式遍历（栈）</h5><p>到这里所有代码的思想都是递归的方式进行遍历比较简单和顺畅，当然也可以利用<strong>栈</strong>这种数据结构来进行非递归遍历。我们还是利用这颗树来进行<strong>前序遍历</strong>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">1((1)) --&gt; 2((2))</span><br><span class="line">1((1)) --&gt; 3((3))</span><br><span class="line">2((2)) --&gt; 4((4))</span><br><span class="line">2((2)) --&gt; 5((5))</span><br><span class="line">3((3)) --&gt; 6((6))</span><br></pre></td></tr></table></figure><p>1、首先遍历二叉树的根节点，放入栈中</p><div class="table-container"><table><thead><tr><th>1</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>2、遍历根节点1的左孩子节点2，放入栈中</p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>3、遍历节点2的左孩子节点4，放入栈中</p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>4</th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>4、节点4没有左孩子也没有右孩子，出栈，回溯到其父节点2，2此时左孩子已访问，还有右孩子未访问，所以节点2出栈，她的右孩子节点5入栈。</p><div class="table-container"><table><thead><tr><th>1</th><th>5</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>5、节点五没有孩子节点，那么我们需要回溯，此时只有根节点1，节点5出栈，节点1出栈，节点1的右孩子节点3入栈。</p><div class="table-container"><table><thead><tr><th>3</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>6、节点三无左孩子，只有右孩子节点6，所以节点3出栈，节点6入栈</p><div class="table-container"><table><thead><tr><th>6</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>7、节点6无孩子，节点6出栈，此时栈为空，遍历结束。</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_order_teaversal_with_stack</span>(<span class="params">node</span>):</span></span><br><span class="line">  stack = []</span><br><span class="line">  <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="built_in">print</span>(node.data)</span><br><span class="line">      stack.append(node)</span><br><span class="line">      node = node.left</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">      node = stack.pop()</span><br><span class="line">      node = node.right</span><br></pre></td></tr></table></figure><h3 id="0x02-广度优先遍历"><a href="#0x02-广度优先遍历" class="headerlink" title="0x02 广度优先遍历"></a>0x02 广度优先遍历</h3><p>我们通过学习<strong>层序遍历</strong>来了解<strong>广度优先遍历</strong>是怎么回事。</p><p>层序遍历就是按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">1((1)) --&gt; 2((2))</span><br><span class="line">1((1)) --&gt; 3((3))</span><br><span class="line">2((2)) --&gt; 4((4))</span><br><span class="line">2((2)) --&gt; 5((5))</span><br><span class="line">3((3)) --&gt; 6((6))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1((1)) --&gt; 2((2))</span><br><span class="line">2((2)) --&gt; 3((3))</span><br><span class="line">3((3)) --&gt; 4((4))</span><br><span class="line">4((4)) --&gt; 5((5))</span><br><span class="line">5((5)) --&gt; 6((6))</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>怎么样，是不是很简单呢？一层一层从向往下从左往右就可以了。可是在同一层的节点之间是没有直接关联的，那我们该怎么去代码实现呢，这里我们借助<strong>队列</strong>来辅助遍历。</p><p>详细遍历步骤如下：</p><p>1、根节点1进入队列</p><div class="table-container"><table><thead><tr><th>1</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>2、节点1出队，输出节点1，并得到节点1的左孩子节点2、右孩子节点3.让节点2、3入队</p><div class="table-container"><table><thead><tr><th>2</th><th>3</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>3、节点2出队，并得到其孩子节点4、5，节点4、5入队</p><div class="table-container"><table><thead><tr><th>3</th><th>4</th><th>5</th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>4、节点3出队，并得到节点3的右孩子节点6，节点6入队</p><div class="table-container"><table><thead><tr><th>4</th><th>5</th><th>6</th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>5、节点4出队，输出节点4，但是节点4没有孩子节点，所以没有新节点入队</p><div class="table-container"><table><thead><tr><th>5</th><th>6</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>6、节点5出队，输出节点5，但是节点5没有孩子节点，故无新节点入队</p><div class="table-container"><table><thead><tr><th>6</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>7、节点6出队，输出节点6，但是节点6没有孩子节点，故无新节点入队，此时队列为空，遍历结束</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order_traversal</span>(<span class="params">node</span>):</span></span><br><span class="line">  queue = Queue()</span><br><span class="line">  queue.put(node)</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> queue.empty():</span><br><span class="line">    node = queue.get()</span><br><span class="line">    <span class="built_in">print</span>(node.data)</span><br><span class="line">    <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      queue.put(node.left)</span><br><span class="line">     <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      queue.put(node.right)</span><br></pre></td></tr></table></figure><p>Todo: </p><ul><li>[ ] 二叉堆相关</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编程学习 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集</title>
      <link href="/post/312e3d12.html"/>
      <url>/post/312e3d12.html</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-收集域名信息"><a href="#0x00-收集域名信息" class="headerlink" title="0x00 收集域名信息"></a>0x00 收集域名信息</h3><h4 id="1-Whois查询"><a href="#1-Whois查询" class="headerlink" title="1. Whois查询"></a>1. Whois查询</h4><p>​     Whois是一个标准的互联网协议，可以收集网络注册信息，如域名、IP地址、服务商、域名拥有者、邮箱、电话、地址等。</p><p>–    爱站工具网（<a href="https://whois.aizhan.com">whois.aizhan.com</a>）</p><p>–    站长之家（<a href="http://whois.chinaz.com">whois.chinaz.com</a>）</p><p>–    VirtusTotal（<a href="https://www.virustotal.com">virustotal.com</a>）</p><h4 id="2-备案信息查询"><a href="#2-备案信息查询" class="headerlink" title="2. 备案信息查询"></a>2. 备案信息查询</h4><p>–    ICP备案查询网：<a href="http://www.beianbeian.com">beianbeian.com</a></p><p>–    天眼查：<a href="http://tianyancha.com">tianyancha.com</a></p><h3 id="0x01-收集敏感信息"><a href="#0x01-收集敏感信息" class="headerlink" title="0x01 收集敏感信息"></a>0x01 <strong>收集敏感信息</strong></h3><p>各种搜索引擎的黑客语法可以用来获取数据库文件、SQL注入、配置信息、源代码泄漏、未授权访问和robots.txt等敏感信息。</p><p>常见的Google语法如下：</p><div class="table-container"><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>Site</td><td>指定域名</td></tr><tr><td>Inurl</td><td>URL中存在关键字的网页</td></tr><tr><td>Intext</td><td>网页正文中的关键字</td></tr><tr><td>Filetype</td><td>指定文件类型</td></tr><tr><td>Intitle</td><td>网页标题中的关键字</td></tr><tr><td>link</td><td>link:baidu.com即表示返回所有和baidu.com做了链接的URL</td></tr><tr><td>Info</td><td>查找指定站点的一些基本信息</td></tr><tr><td>cache</td><td>搜索Google里关于某些内容的缓存</td></tr></tbody></table></div><h3 id="0x02-收集子域名信息"><a href="#0x02-收集子域名信息" class="headerlink" title="0x02 收集子域名信息"></a>0x02 <strong>收集子域名信息</strong></h3><h4 id="1-常用工具"><a href="#1-常用工具" class="headerlink" title="1. 常用工具"></a>1. 常用工具</h4><p>–    Layer子域名挖掘机 简单易用，安全测试人员常用</p><p>–    subDomainBrute 可以用小字典递归发现多级域名</p><p>–    Sublist3r 可以列举多种资源，如Google、Yahoo、Bing、Netcraft、ThreadCrowd等查到的子域名</p><h4 id="2-搜索引擎枚举"><a href="#2-搜索引擎枚举" class="headerlink" title="2. 搜索引擎枚举"></a>2. 搜索引擎枚举</h4><h4 id="3-第三方聚合应用枚举"><a href="#3-第三方聚合应用枚举" class="headerlink" title="3. 第三方聚合应用枚举"></a>3. 第三方聚合应用枚举</h4><p>也可以用DNSdumpster网站（<a href="http://dnsdumpster.com">dnsdumpster.com</a>）、在线DNS侦查和搜索工具挖掘出指定域潜藏的大量子域。</p><h4 id="4-证书透明度公开日志枚举"><a href="#4-证书透明度公开日志枚举" class="headerlink" title="4. 证书透明度公开日志枚举"></a>4. 证书透明度公开日志枚举</h4><p>证书授权机构会将每个SSL/TLS证书发布到公共日志中。一个SSL/TLS证书通常包含域名、子域名和邮箱地址。</p><p>–    crt.sh: <a href="https://crt.sh">crt.sh</a></p><p>–    censys: <a href="https://censys.io">censys.io</a></p><p>–    子域名爆破网站（<a href="https://phpinfo.me/domain">phpinfo.me/domain</a>）</p><p>–    IP反查域名绑定网站（<a href="http://aizhan.com">aizhan.com</a>）</p><h3 id="0x03-收集常用端口信息"><a href="#0x03-收集常用端口信息" class="headerlink" title="0x03 收集常用端口信息"></a>0x03 <strong>收集常用端口信息</strong></h3><p>常见端口号对应服务如下表</p><p>–    <strong>文件共享服务类</strong></p><div class="table-container"><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方向</th></tr></thead><tbody><tr><td>21/22/69</td><td>Ftp/Tftp文件传输协议</td><td>允许匿名的上传、下载、爆破和嗅探</td></tr><tr><td>2049</td><td>Nfs服务</td><td>配置不当</td></tr><tr><td>139</td><td>Samba服务</td><td>爆破、未授权访问、远程代码执行</td></tr><tr><td>389</td><td>Ldap目录访问协议</td><td>注入、允许匿名访问、弱口令</td></tr></tbody></table></div><p>–    <strong>远程连接服务类</strong></p><div class="table-container"><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方向</th></tr></thead><tbody><tr><td>22</td><td>SSH远程连接</td><td>爆破、SSH隧道及内网代理转发、文件传输</td></tr><tr><td>23</td><td>Telnet远程连接</td><td>爆破、嗅探、弱口令</td></tr><tr><td>3389</td><td>Rdp远程桌面连接</td><td>Shift后门（需要Windows Server 2003一下系统）爆破</td></tr><tr><td>5900</td><td>VNC</td><td>弱口令爆破</td></tr><tr><td>5632</td><td>PyAnywhere服务</td><td>抓密码、代码执行</td></tr></tbody></table></div><p>–    <strong>Web</strong> <strong>应用服务类</strong></p><div class="table-container"><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方向</th></tr></thead><tbody><tr><td>80/443/8080</td><td>常见的Web服务端口</td><td>Web攻击、爆破、对应服务器版本攻击</td></tr><tr><td>7001/7002</td><td>WebLogic控制台</td><td>Java反序列化、弱口令</td></tr><tr><td>8080/8089</td><td>Jboss/Resin/Jetty/Jenkins</td><td>反序列化、控制台弱口令</td></tr><tr><td>9090</td><td>WebSphere控制台</td><td>Java反序列化、弱口令</td></tr><tr><td>4848</td><td>GlassFish控制台</td><td>弱口令</td></tr><tr><td>1352</td><td>Lotus domino邮件服务</td><td>弱口令、信息泄漏、爆破</td></tr><tr><td>10000</td><td>Webmin-Web控制面板</td><td>弱口令</td></tr></tbody></table></div><p>–    <strong>数据库服务类</strong></p><div class="table-container"><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方向</th></tr></thead><tbody><tr><td>3306</td><td>MySQL</td><td>注入、提权、爆破</td></tr><tr><td>1433</td><td>MSSQL数据库</td><td>注入、提权、SA弱口令、爆破</td></tr><tr><td>1521</td><td>Oracle数据库</td><td>TNS爆破、注入、反弹shell</td></tr><tr><td>5432</td><td>PostSQL数据库</td><td>注入、爆破、弱口令</td></tr><tr><td>27017/27018</td><td>MongoDB</td><td>爆破、未授权访问</td></tr><tr><td>6379</td><td>Redis数据库</td><td>可尝试未授权访问、弱口令爆破</td></tr><tr><td>5000</td><td>SysBase/DB2数据库</td><td>爆破、注入</td></tr></tbody></table></div><p>–    <strong>邮件服务类</strong></p><div class="table-container"><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方式</th></tr></thead><tbody><tr><td>25</td><td>SMTP邮件服务</td><td>邮件伪造</td></tr><tr><td>110</td><td>POP3协议</td><td>爆破、嗅探</td></tr><tr><td>143</td><td>IMAP协议</td><td>爆破</td></tr></tbody></table></div><p>–    <strong>网络常见协议类</strong></p><div class="table-container"><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方式</th></tr></thead><tbody><tr><td>53</td><td>DNS域名系统</td><td>允许区域传送、DNS劫持、缓存投毒、欺骗</td></tr><tr><td>67/68</td><td>DHCP服务</td><td>劫持、欺骗</td></tr><tr><td>161</td><td>SNMP协议</td><td>爆破、搜集目标内网信息</td></tr></tbody></table></div><p>–    <strong>特殊服务类</strong></p><div class="table-container"><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方式</th></tr></thead><tbody><tr><td>2181</td><td>ZooKeeper服务</td><td>未授权访问</td></tr><tr><td>8069</td><td>Zabbix服务</td><td>远程执行、SQL注入</td></tr><tr><td>9200/9300</td><td>Elasticsearch服务</td><td>未授权访问</td></tr><tr><td>11211</td><td>Memcache服务</td><td>未授权访问</td></tr><tr><td>512/513/514</td><td>Linux Rexec服务</td><td>爆破、Rlogin服务</td></tr><tr><td>873</td><td>Rsync服务</td><td>匿名访问、文件上传</td></tr><tr><td>3690</td><td>Svn服务</td><td>Svn泄漏、未授权访问</td></tr><tr><td>50000</td><td>SAP Management Console</td><td>远程执行</td></tr></tbody></table></div><h3 id="0x04-指纹识别"><a href="#0x04-指纹识别" class="headerlink" title="0x04 指纹识别"></a>0x04 指纹识别</h3><p>​    应用程序一般在html、js、css等文件中会存在一些特征码，比如WordPress在robots.txt中会包含wp-admin\首页index.php中会包含generator=wordpress 3.xx等信息。这就叫做该CMS的指纹。</p><p>​    常见的CMS有Dedecms（织梦）、Discuz、PHPWEB、PHPWind、PHPCMS、ECShop、Dvbbs、SiteWeaver、ASPCMS、帝国、Z-Blog、WordPress等。</p><p>​    代表工具也有御剑Web指纹识别、WhatWeb、WebRobo、椰树等，当然也可以利用一些在线网站查询CMS指纹识别：</p><p>–    BugScanner：<a href="http://whatweb.bugscaner.com/look/">whatweb.bugscaner.com/look/</a></p><p>–    云悉指纹: <a href="http://www.yunsee.cn/finger.html">www.yunsee.cn/finger.html</a></p><p>–    WhatWeb:<a href="https://whatweb.net/">whatweb.net</a></p><h3 id="0x05-查找真实IP"><a href="#0x05-查找真实IP" class="headerlink" title="0x05 查找真实IP"></a>0x05 查找真实IP</h3><p><strong>1.</strong> <strong>判断目标网站是否使用了</strong> <strong>CDN</strong> <strong>（即内容分发网络，可以提高网站的响应速度）</strong></p><p>​    如果目标服务器有CDN服务，我们直接ping域名的话，得到的会是离我们最近的一台目标节点的CDN服务器，这时我们可以利用在线网站17CE（<a href="https://17ce.com">17ce.com</a>）进行全国多地区的ping服务器操作，然后对比每个地区的ping出IP的结果，看看是否一致，如果都是一样的，那么目标不存在CDN服务器，如果IP大多不一样或着有规律性，则可以尝试查询这些IP的归属地，判断是否有CDN。</p><p><strong>2.</strong> <strong>绕过</strong> <strong>CDN</strong> <strong>寻找真实</strong> <strong>IP</strong></p><p>–    内部邮箱源。一般的邮件系统存在内部，没有经过CDN的解析，通过目标网站用户注册或者RSS订阅功能，查看邮件、寻找邮件头中的邮件服务器域名IP，ping这个邮件服务器域名，就能获取目标真实IP（当然这个服务器必须是目标自己的，若是第三方公共邮箱就没有意义了）</p><p>–    扫描网站测试文件，如phpinfo、test等，从而找到真实的IP。</p><p>–    分站域名。一般的都是主站挂CDN但是分站没有，可能会出现不是同一个IP但是在同一个c段下的情况。从而可以判断出目标的真实IP段。</p><p>–    国外访问。国内的CDN只针对国内用户访问加速，但是国外的CDN就不一定了。通过国外在线代理网站APP Synthetic Monitor（<a href="http://asm.ca.com/en/ping.php">asm.ca.com/en/ping.php</a>）访问，可能会得到真实的IP。</p><p>–    查询域名的解析记录。可以通过网站NETCRAFT（<a href="http://netcraft.com">netcraft.com</a>）来观察域名的IP历史记录，也可以大致分析出目标的真实IP段。</p><p>–    如果目标网站有自己的App，可以尝试抓包，从数据包内分析真实IP</p><p>–    绕过CloudFlare CDN查找真实IP。很多网站都使用了CloudFlare提供的CDN服务，可以尝试通过在线网站CloudFlareWatch（<a href="http://www.crimeflare.us/cfs.html#box">www.crimeflare.us/cfs.html#box</a>）对CloudFlare客户网站进行真实的IP查询</p><p><strong>3.</strong> <strong>验证获取的</strong> <strong>IP</strong></p><p>最简单的就是访问IP，比较访问域名返回的结果是否一致，若目标段较大，可以借助Masscan的工具批量扫描对应IP段中所有开了80、8080、443端口的IP，逐个访问。</p><h3 id="0x06-收集敏感目录文件"><a href="#0x06-收集敏感目录文件" class="headerlink" title="0x06 收集敏感目录文件"></a>0x06 收集敏感目录文件</h3><p>在渗透测试中，探测Web目录结构和隐藏的敏感文件是一个必不可少的环节，从中可以获取网站的后台管理页面、文件上传界面，甚至源代码。</p><p>针对网站目录扫描主要有：DirBuster、御剑后台扫描珍藏版、wwwscan、Spinder.py、Sensitivefilescan、Weakfilescan等工具。也可以访问在线网站WebScan（<a href="http://www">www</a>.webscan.cc/）</p><h3 id="0x07-社会工程学"><a href="#0x07-社会工程学" class="headerlink" title="0x07 社会工程学"></a>0x07 社会工程学</h3><p>针对人来下手。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Web安全攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nmap小技巧</title>
      <link href="/post/dbf508ef.html"/>
      <url>/post/dbf508ef.html</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-Nmap列举远程机器开放的端口原理"><a href="#0x00-Nmap列举远程机器开放的端口原理" class="headerlink" title="0x00 Nmap列举远程机器开放的端口原理"></a>0x00 Nmap列举远程机器开放的端口原理</h3><p>首先判断nmap输入的命令中是否包含域名，如果包含需要利用DNS服务器进行域名解析，然后发送ICMP Echo Request来探测主机的存活性。若目标主机存活，nmap则向目标发送数据包，然后目标主机会做出回应，回包给nmap，nmap就根据返回的数据包来得到机器信息，其中就包含端口信息。</p><h5 id="可以使用【nmap-domain-name】来探测"><a href="#可以使用【nmap-domain-name】来探测" class="headerlink" title="可以使用【nmap domain_name】来探测"></a>可以使用【nmap domain_name】来探测</h5><ul><li>nmap在探测之前把域名通过DNS服务器解析为IP地址，也可以用执行的DNS服务器进行解析。使用          —dns-server参数来指定</li><li>对于已知主机存活或者防火墙开启的机器，可以使用-Pn参数来停止探测之前的ICMP请求。以达到不触发防火墙安全机制。</li><li>对于默认的端口范围，不能满足日常需要。可以使用-p m-n来指定探测端口范围之间的所有端口</li></ul><h5 id="端口状态："><a href="#端口状态：" class="headerlink" title="端口状态："></a>端口状态：</h5><ul><li>Open               表示端口处于开放状态</li><li>Closed             关闭</li><li>Filterd              表示端口处于过滤无法收到返回的probe状态</li><li>UnFilterd         表示端口收到返回的probe，但是无法确认</li><li>Opened/UnFilterd       表示端口处于开放或者是过滤状态</li><li>Closed/UnFilterd          表示端口处于关闭或者是未过滤状态</li></ul><h3 id="0x01-Nmap发现局域网中存活主机"><a href="#0x01-Nmap发现局域网中存活主机" class="headerlink" title="0x01 Nmap发现局域网中存活主机"></a>0x01 Nmap发现局域网中存活主机</h3><h4 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h4><ul><li><p><code>ping ip</code> 手工探测，但是很费劲</p></li><li><p>CIDR（无类别域间路由），可以快速表示一个网络</p><p><code>172.16.1.1/24 = 172.16.1.1～172.16.1.255</code> 表示该域下所有主机IP地址</p></li><li><p><code>nmap -sP CIDR</code> 对该网络所有的主机进行Ping扫描，以探测主机存活性。扫描过程中使用了<strong>TCP、SYN扫描</strong>、<strong>ICMP echo Request来探测主机存活</strong></p></li><li><p><code>nmap -sn CIDR</code> 对网络中所有主机进行Ping扫描，探测主机的存活性</p></li><li><p><code>nmap -sn CIDR -oX file_name.xml</code> 将探测结果保存到xml文件中</p></li></ul><h3 id="0x02-Nmap识别目标机器上服务的指纹"><a href="#0x02-Nmap识别目标机器上服务的指纹" class="headerlink" title="0x02 Nmap识别目标机器上服务的指纹"></a>0x02 Nmap识别目标机器上服务的指纹</h3><h4 id="服务指纹"><a href="#服务指纹" class="headerlink" title="服务指纹"></a>服务指纹</h4><p>为了确保有一个成功的滲透测试或网络设备监控，必须知道目标系统中服务的指纹信息。服务指纹信息包括服务端口、服务名和版本等。</p><p>通过分析目标往Nmap发送的数据包中某些协议标记、选项和数据，我们可以推断发送这些数据包的操作系统等。</p><p> nmap通过向目标主机发送多个UDP与TCP数据包冰分析其响应来进行操作系统指纹识别工作。</p><p>使用命令<code>nmap -sV IP</code>来识别目标机器的服务信息</p><p><strong>Nmap的倾略性探测</strong></p><ul><li><code>nmap -A -v -T4 IP</code>  </li><li><code>nmap -sC -sV -O IP</code></li></ul><p>以上两条命令都是使用Nmap来探测目标机器的操作系统、服务等信息。其中<code>-sC</code>表示使用Nmap脚本探测，<code>-sV</code>表示探测目标服务器上的服务信息，<code>-O</code>表示探测目标服务器的操作系统信息。</p><p>Tips：<code>-sC:equivalent to -script=default</code></p><h3 id="0x03-Nmap的NSE脚本使用"><a href="#0x03-Nmap的NSE脚本使用" class="headerlink" title="0x03 Nmap的NSE脚本使用"></a>0x03 Nmap的NSE脚本使用</h3><h4 id="NSE脚本介绍"><a href="#NSE脚本介绍" class="headerlink" title="NSE脚本介绍"></a>NSE脚本介绍</h4><p> NSE（Nmap Script Engine）Nmap脚本引擎，内置很多可以用来扫描的、针对特定任务的脚本。通过NSE可以不断拓展Nmap扫描策略，加强Nmap的功能。</p><p> Nmap中使用—script参数来指定调用的脚本，并且脚本存储在Nmap安装路径下的script文件夹下，对于kali linux存储在/usr/share/nmap/script/下。</p><h4 id="NSE使用"><a href="#NSE使用" class="headerlink" title="NSE使用"></a>NSE使用</h4><ul><li><code>nmap --script script_name IP</code>         使用Nmap探测Web服务的title信息</li><li><code>nmap --script http-headers IP</code>       使用Nmap探测http服务的http头</li></ul><h4 id="NSE分类使用"><a href="#NSE分类使用" class="headerlink" title="NSE分类使用"></a>NSE分类使用</h4><p>对于目标使用多个分类脚本进行探测，可以更快的找到目标的信息与弱点。</p><ul><li><p>使用Nmap中漏洞分类脚本对目标进行探测，使用命令如下：</p><p><code>nmap -sV --script vuln IP</code></p></li><li><p>使用Nmap中发现和版本信息分类进行探测，使用命令如下：</p><p><code>nmap -sV --script=&quot;version, discovery&quot; IP</code></p></li><li><p>使用Nmap除了exploit分类之外的其它分类进行探测，使用命令如下：</p><p><code>nmap -sV --script=&quot;not exploit&quot; IP</code></p></li><li><p>使用Nmap中http*的脚本，但是除了（http-brute和http-slowlors）,使用命令如下：</p><p><code>nmap -sV --script &quot;(http*) and not (http-slowlors and http-brute)&quot; IP</code></p></li></ul><h3 id="0x04-Nmap端口探测小技巧"><a href="#0x04-Nmap端口探测小技巧" class="headerlink" title="0x04 Nmap端口探测小技巧"></a>0x04 Nmap端口探测小技巧</h3><ul><li><code>nmap -p port_number ip</code> 对某个端口进行探测</li><li><code>nmap -p port_number1,port_number2... IP</code>  对某几个端口进行探测</li><li><code>nmap -p1-100 ip</code>  对某个范围端口进行探测</li><li><code>nmap -p- ip</code>  全端口探测</li><li><code>nmap -p T:25,U:53 IP</code>  指定协议来探测端口</li><li><code>nmap -p smtp IP</code>  通过协议名来扫描端口</li><li><code>nmap -p s* ip</code>  通过名称范围扫描</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题分享</title>
      <link href="/post/dbc79228.html"/>
      <url>/post/dbc79228.html</url>
      
        <content type="html"><![CDATA[<p>今天又折腾了一下博客，想着慢慢积累知识并定期分享出来，当然也是监督自己时刻都在学习，然后现在把之前面试中遇到的问题归纳了一下，各位大佬肯定觉得很简单，但也是对我早期学习经历的一次总结吧。</p><h4 id="Python常用小脚本"><a href="#Python常用小脚本" class="headerlink" title="Python常用小脚本"></a>Python常用小脚本</h4><ul><li>端口扫描</li></ul><ul><li>文件上传</li></ul><ul><li>TCP交互</li></ul><ul><li>目录扫描</li></ul><h4 id="文件上传如何绕WAF"><a href="#文件上传如何绕WAF" class="headerlink" title="文件上传如何绕WAF"></a>文件上传如何绕WAF</h4><p>首先猜测WAF类型：</p><p>​    D盾file_nameH改变大小写、连等号（3个）===、回车 file_name=====”index.pHp”或其它的各种解析漏洞</p><p>WAF的动态二进制查杀&lt;-内容，太大了不会全部查看</p><h4 id="MySQL数据库下有哪些默认数据库"><a href="#MySQL数据库下有哪些默认数据库" class="headerlink" title="MySQL数据库下有哪些默认数据库"></a>MySQL数据库下有哪些默认数据库</h4><p>information_schema:储存其它数据库的表名和字段名</p><h4 id="MySQL提权有哪些手段"><a href="#MySQL提权有哪些手段" class="headerlink" title="MySQL提权有哪些手段"></a>MySQL提权有哪些手段</h4><ul><li>UDF提权</li></ul><ul><li>写文件提权（要知道网站的绝对路径）</li></ul><h4 id="CSRF如何利用"><a href="#CSRF如何利用" class="headerlink" title="CSRF如何利用"></a>CSRF如何利用</h4><p>XSS联动利用</p><h4 id="SSRF如何利用"><a href="#SSRF如何利用" class="headerlink" title="SSRF如何利用"></a>SSRF如何利用</h4><p>file:///读文件</p><p>dict:///主机探活</p><h4 id="内网怎么横向渗透"><a href="#内网怎么横向渗透" class="headerlink" title="内网怎么横向渗透"></a>内网怎么横向渗透</h4><p>假设现在有A主机、B主机</p><p>Cweb服务器&lt;—— mimikatz 抓取密码hash爆破</p><p>windows然后3389远程登录</p><p>administrator、admin</p><p>linux 22端口登录</p><p>root、webroot、admin</p><p>arp探测主机存活性</p><p>端口探测80端口、探测资产</p><h4 id="CDN如何绕过"><a href="#CDN如何绕过" class="headerlink" title="CDN如何绕过"></a>CDN如何绕过</h4><p>多地址ping请求 <a href="http://www.chinaz.com">www.chinaz.com</a></p><p>查看DNS历史记录 <a href="http://www.dnsdb.io/zh-cn/">www.dnsdb.io/zh-cn/</a></p><h4 id="SQL注入怎么绕WAF"><a href="#SQL注入怎么绕WAF" class="headerlink" title="SQL注入怎么绕WAF"></a>SQL注入怎么绕WAF</h4><ul><li>大小写绕过 pHp</li></ul><ul><li>双写绕过   str_replace(find, replace, string, count)  pphphp</li></ul><ul><li>注释符绕过</li></ul><ul><li>函数截断 substr left() right()</li></ul><h4 id="文件上传的解析漏洞有了解过吗"><a href="#文件上传的解析漏洞有了解过吗" class="headerlink" title="文件上传的解析漏洞有了解过吗"></a>文件上传的解析漏洞有了解过吗</h4><p>多后缀解析漏洞：Apache的文件解析顺序是从右向左，它会解析它认得的 text.php.345.fgd.jfd,那么会被解析成php文件</p><p>用hex功能在1.php后面加一个\x0A</p><p>IIS6.0 test.php;.jpg test.php4/5/7 test.phtml/phpr</p><p>IIS7.5 test.jpg/.php</p><p>Windows::$DATA 00截断</p><h4 id="XSS只能盗取cookie吗"><a href="#XSS只能盗取cookie吗" class="headerlink" title="XSS只能盗取cookie吗"></a>XSS只能盗取cookie吗</h4><p>粘贴板漏洞攻击</p><p>盗链、暗链</p><h4 id="说一下SQL注入原理"><a href="#说一下SQL注入原理" class="headerlink" title="说一下SQL注入原理"></a>说一下SQL注入原理</h4><p>攻击者通过构造恶意的SQL语句传入到数据库中，执行后破坏了原有的语法结构。</p><p>漏洞挖掘、闭合-&gt;字段-&gt;显示位置-&gt;数据库名（MySQL）-&gt;表名-&gt;列名-&gt;敏感数据</p><p>利用SQL注入写文件（木马）-&gt;file_input D:/web/data/-&gt;Sqlmap —os-shell</p><p>平时怎么去挖掘：平时注意与数据库交互的一些参数，不要放过每一个参数，尤其关注后台、内网的一些参数点。</p><p>SQL防护 PDO、预编译</p><ul><li>[ ] 了解过XXE吗？</li><li>[ ] 用最简单的方式判断sql注入的数据库类型</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

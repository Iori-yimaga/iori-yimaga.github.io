<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>内网穿透之玩转花生壳-入门篇</title>
      <link href="/2021/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E4%B9%8B%E7%8E%A9%E8%BD%AC%E8%8A%B1%E7%94%9F%E5%A3%B3-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
      <url>/2021/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E4%B9%8B%E7%8E%A9%E8%BD%AC%E8%8A%B1%E7%94%9F%E5%A3%B3-%E5%85%A5%E9%97%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-前景一提"><a href="#0x00-前景一提" class="headerlink" title="0x00 前景一提"></a>0x00 前景一提</h3><p>家里闲置了一个树莓派好久，一直想拿它做点什么，又一直不知道能做些什么，其实关于它的教程网上一直有很多，特别是某小破站，这里我推荐一下树莓派的最佳项目，感兴趣的小伙伴们可以自行观看：</p><center><div class="tag link"><a class="link-card" title="2019年最棒的十大树莓派项目" href="https://www.bilibili.com/video/BV1ot411P75G?from=search&seid=13110630399688723319"><div class="left"><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/PiProj.ico"/></div><div class="right"><p class="text">2019年最棒的十大树莓派项目</p><p class="url">https://www.bilibili.com/video/BV1ot411P75G?from=search&seid=13110630399688723319</p></div></a></div></center><p>后来我知道可以将内网IP映射到公网我才突然想起啦家里还有个吃灰的小板子，话不多说，咱们立马开动。</p><h3 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h3><p>首先，我们要有一块树莓派，这里我用的是树莓派3b，<del>老伙伴了</del>，它是这样子的: <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg3.mukewang.com%2F5bf1507c0001c84e04500302.jpg&refer=http%3A%2F%2Fimg3.mukewang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1628091543&t=419d7a50b41c411a81ad5b34fc971925" alt="pi" style="zoom:60%;" /></p><p>我们先进入<a href="https://www.raspberrypi.org/software/raspberry-pi-desktop/">树莓派官网</a>找对应的系统下载到电脑上，然后找来一张TF卡，插入读卡器后连接到电脑，可以利用主流的烧录镜像的软件把固件烧录到TF卡上，最原始的就是利用命令行工具啦，最帅<del>bushi</del>，由于我用的MacOS是类Unix系统，可以直接用大部分linux的命令，当然用linux/unix系统的童鞋也可以参考我的<a href="https://www.runoob.com/linux/linux-comm-dd.html">dd命令</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=~/Downloads/pi.os of=/dev/mmcblk0 status=progress bs=4M</span><br></pre></td></tr></table></figure><p>烧录好之后就可以把TF卡插进树莓派背部的小卡槽啦，接上电源，插上各种外设，通电～过一会儿就可以看到画面了。</p><p><strong>Tips：</strong>如果没有外接显示器的同学可以直接用ssh连接，前提是得开启wifi和ssh，这一节我会在文章最后的补充中专门介绍。</p><p>话接上文，开启屏幕后，我们先打开屏幕右上角的wifi图标，选择好输入密码后就联网了，然后我们打开终端，先输入<code>sudo apt update &amp;&amp; sudo apt upgrade</code>进行常规的系统升级，然后点击屏幕左上角的树莓派logo，点击<strong>首选项</strong>—&gt;<strong>Raspberry Pi Configuration</strong>，然后点击<strong>Interfaces</strong>选项卡，就能看到SSH啦，勾选Enable就可以了。此时它已经不需要所有外设了，仅仅只要一根电源线给它供电就行。</p><h3 id="0x02-步入正轨"><a href="#0x02-步入正轨" class="headerlink" title="0x02 步入正轨"></a>0x02 步入正轨</h3><h4 id="1、安装花生壳"><a href="#1、安装花生壳" class="headerlink" title="1、安装花生壳"></a>1、安装花生壳</h4><p>我们先去<a href="https://hsk.oray.com/download/">花生壳</a>找符合自己树莓派系统的安装包，这里我的树莓派是32位系统，就下载这个：<br><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed/MyBlog/hsk.png" alt="hsk" style="zoom:60%;" /></p><p>然后就会得到一个deb文件，这是debian系linux的标准安装包，可是这个在我们电脑上啊，怎么把它传到树莓派上呢，这时就可以使用<a href="https://www.runoob.com/linux/linux-comm-scp.html">scp命令</a>，我的如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~/Downloads/pi.deb pi@192.168.**.**:/home/pi/Downloads/</span><br></pre></td></tr></table></figure><p>Tips：@后面跟的是你的树莓派的IP地址哦</p><p>这时再来看我们树莓派位文件目录，Downloads下就有我们传过去的pi.deb啦:</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/pideb.png" alt="pideb"></p><p>接着输入<code>sudo depkg -i pi.deb</code>等待安装完毕即可。安装完毕后就会显示设备账户初始信息，包括SN码和初始密码，以及远程管理网址，当然之后也可以通过命令<code>sudo phddns status</code>来查看：</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/phddns.png" alt="phddns"></p><h4 id="2、登陆配置"><a href="#2、登陆配置" class="headerlink" title="2、登陆配置"></a>2、登陆配置</h4><p>在浏览器输入网址<a href="http://b.oray.com进入远程管理接口，输入对应的SN码和初始密码admin就能进去啦，之后就按照要求进行绑定手机，重设密码之类的操作，这里我就不多说了。">http://b.oray.com进入远程管理接口，输入对应的SN码和初始密码admin就能进去啦，之后就按照要求进行绑定手机，重设密码之类的操作，这里我就不多说了。</a></p><p>进入管理页面后我们点击<strong>内网穿透</strong>—&gt;<strong>添加映射</strong>，访问地址就填写自己树莓派的IP地址，端口就是ssh默认的22端口，点击保存，等页面运行一下，咱们的树莓派就可以用公网IP进行通信啦！花生壳会给我们分配一个公网域名、公网IP和一个端口，我们可以在非局域网的环境中指挥我们的树莓派工作了。</p><p>点击诊断，就可以查看公网IP和端口了。</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed@main/MyBlog/zhenduan.png" alt="zhenduan" style="zoom:80%;" /></p><p>当然我们也可以在手机上下载花生壳App来管理和查看我们的设备工作情况。怎么样，是不是很方便呢？</p><p>从此树莓派不断电～～～我们可以用它公网IP和映射的端口来操作它了。</p><h3 id="0x03-补充"><a href="#0x03-补充" class="headerlink" title="0x03 补充"></a>0x03 补充</h3><h4 id="1、WiFi配置"><a href="#1、WiFi配置" class="headerlink" title="1、WiFi配置"></a>1、WiFi配置</h4><p>用户可以在未启动树莓派的状态下单独更改<code>/boot/wap_supplicant.conf</code>文件配置WiFi的SSID和密码，这样树莓派在通电启动后自行读取wpa_supplicant.conf配置文件连接WiFi设备。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">country=CN</span></span><br><span class="line"><span class="string">ctrl_interface=DIR=/var/run/wpa_supplicant</span> <span class="string">GROUP=netdev</span></span><br><span class="line"><span class="string">update_config=1</span></span><br><span class="line"></span><br><span class="line"><span class="string">network=&#123;</span></span><br><span class="line">  <span class="string">ssid=&quot;你的WiFi名&quot;</span></span><br><span class="line">  <span class="string">psk=&quot;你的WiFi密码&quot;</span></span><br><span class="line">  <span class="string">key_mgmt=WPA-PSK</span></span><br><span class="line">  <span class="string">priority=1</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">network=&#123;</span></span><br><span class="line"><span class="string">ssid=&quot;你的WiFi名&quot;</span></span><br><span class="line">  <span class="string">psk=&quot;你的WiFi密码&quot;</span></span><br><span class="line">  <span class="string">key_mgmt=WPA-PSK</span></span><br><span class="line">  <span class="string">priority=2</span></span><br><span class="line">  <span class="string">scan_ssid=1</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>说明一下</strong>：</p><ul><li>ssid就是网络的SSID</li><li>psk就是密码</li><li>priority是连接的优先级买数字越大优先级越高（不可以取负数）</li><li>scan_ssid连接隐藏的WiFi时需要指定该值为1</li></ul><p>如果你的WiFi没有密码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">network=&#123;</span></span><br><span class="line"><span class="string">ssid=&quot;你的WiFi名&quot;</span></span><br><span class="line"><span class="string">key_mgmt=NONE</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>如果你的WiFi使用WEP加密：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">network=&#123;</span></span><br><span class="line"><span class="string">ssid=&quot;你的WiFi名&quot;</span></span><br><span class="line"><span class="string">key_mgmt=NONE</span></span><br><span class="line"><span class="string">wep_key0=&quot;你的WiFi密码&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>如果你的WiFi使用WPA/WPA2加密：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">network&#123;</span></span><br><span class="line"><span class="string">ssid=&quot;你的无线网络名称（ssid）&quot;</span></span><br><span class="line"><span class="string">key_mgmt=WPA-PSK</span></span><br><span class="line"><span class="string">psk=&quot;你的wifi密码&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2、开启ssh服务"><a href="#2、开启ssh服务" class="headerlink" title="2、开启ssh服务"></a>2、开启ssh服务</h4><p>和配置WiFi的方式相似，我们可以直接在TF卡的根目录下新建一个SSH文件（无后缀），这里网上其实还有很多介绍的教程，但是根据情况哈，这里我们是配好了网，没有显示器的情况下来开启ssh，貌似只有这一种方法了。不过也可能有疏漏，欢迎各路大佬来补充和指正～</p>]]></content>
      
      
      <categories>
          
          <category> 折腾日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件推荐 </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> 折腾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于基站定位的商圈分析</title>
      <link href="/2021/%E5%9F%BA%E4%BA%8E%E5%9F%BA%E7%AB%99%E5%AE%9A%E4%BD%8D%E7%9A%84%E5%95%86%E5%9C%88%E5%88%86%E6%9E%90/"/>
      <url>/2021/%E5%9F%BA%E4%BA%8E%E5%9F%BA%E7%AB%99%E5%AE%9A%E4%BD%8D%E7%9A%84%E5%95%86%E5%9C%88%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-任务背景"><a href="#0x00-任务背景" class="headerlink" title="0x00 任务背景"></a>0x00 任务背景</h3><p>随着个人手机终端的普及，手机移动网络也基本实现了城乡空间区域的全覆盖。根据手机信号在真实地理空间上的覆盖情况，将手机用户时间序列的手机定位数据，映射至现实的地理空间位置，即可完整、客观地还原出手机用户的现实活动轨迹，从而挖掘得到人口空间分布与活动联系的特征信息。<br>        商圈是现代市场中企业市场活动的空间，同时也是商品和服务享用者的区域。商圈划分的目的之一是研究潜在的顾客分布，以制定适宜的商业对策。</p><h3 id="0x01-数据挖掘目标"><a href="#0x01-数据挖掘目标" class="headerlink" title="0x01 数据挖掘目标"></a>0x01 数据挖掘目标</h3><ol><li>对用户的历史定位数据，采用数据挖掘技术，对基站进行分群。</li><li>对不同的商圈分群进行特征分析，比较不同商圈类别的价值，选择合适的区域进行运营商的促销活动。</li></ol><h3 id="0x02-语句探索与预处理"><a href="#0x02-语句探索与预处理" class="headerlink" title="0x02 语句探索与预处理"></a>0x02 语句探索与预处理</h3><p>数据挖掘的目标主要是为了找出高价值的商业圈，高价值的商业圈具有人流大，人均停留时间长的特点。但是工作区在工作日也有人流大，人流时间长的特点，经过分析，选取工作日人均停留时间，周末人均停留时间，凌晨人均停留时间，日均人流能量几个特征进行建模和分析。</p><p>首先观察一下原始数据，先选取了前十条观测一下：</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed/MyBlog/image-20210701101506924.png" alt="image-20210701101506924"></p><p>可以发现各属性的量级差异比较大，处理不太方便，需要标准化处理一下，数据的标准化是将数据按比例缩放，把他们落入一个小的特定的区间，便于不同单位或量级的指标能进行比较和加权。常用的方法有「离差标准化」、「log函数变换」、「atan函数转换」、「z-score标准化」、「归一化方法」等。</p><p>这里我们可以采用离差标准化来处理数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数初始化</span></span><br><span class="line"><span class="comment"># 原始数据文件</span></span><br><span class="line">ori_data = <span class="string">&#x27;data/business_circle.xls&#x27;</span></span><br><span class="line"><span class="comment"># 标准化文件传输出路径</span></span><br><span class="line">standardizedfile = <span class="string">&#x27;data/standardized.xls&#x27;</span></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">data = pd.read_excel(ori_data, index_col=<span class="string">u&#x27;基站编号&#x27;</span>)</span><br><span class="line"><span class="comment"># 离差标准化</span></span><br><span class="line">data = (data - data.<span class="built_in">min</span>()) / (data.<span class="built_in">max</span>() - data.<span class="built_in">min</span>())</span><br><span class="line">data = data.reset_index()</span><br><span class="line"><span class="comment"># 保存结果</span></span><br><span class="line">data.to_excel(standardizedfile, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed/MyBlog/image-20210701101535597.png" alt="image-20210701101535597"></p><p>可以看出数据已经被归化在[0,1]这个区间内，降低了原始数据的差异对结果的影响。</p><h3 id="0x03-模型构建与评价"><a href="#0x03-模型构建与评价" class="headerlink" title="0x03 模型构建与评价"></a>0x03 模型构建与评价</h3><p>这里可以采用层次聚类的方法对数据集进行层次分解，直到满足某种条件。在已经得到距离值之后，元素间可以被联系起来。通过分离和融合可以构建一个结构。传统上，表示的方法是树形数据结构，层次聚类算法，要么是自底向上聚集型的，即从叶子节点开始，最终汇聚到根节点；要么是自顶向下分裂型的，即从根节点开始，递归的向下分裂。最终去查看每一类商圈的特征。</p><p>但是首先要知道分成多少类比较合适，即得出k值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.cluster.hierarchy <span class="keyword">import</span> linkage, dandrogram</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数初始化</span></span><br><span class="line">standardizedfile = <span class="string">&#x27;data/standardized.xls&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">data = pd.read_excel(standardizedfile, index_col=<span class="string">u&#x27;基站编号&#x27;</span>)</span><br><span class="line"><span class="comment"># 谱系聚类图</span></span><br><span class="line">Z = linkage(data, method=<span class="string">&#x27;ward&#x27;</span>, metric=<span class="string">&#x27;euclidean&#x27;</span>)</span><br><span class="line">P = dendrogram(Z, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">&#x27;output/px.png&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后观察输出的图片：</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed/MyBlog/image-20210701101601434.png" alt="image-20210701101601434"></p><p>可以看出分成了三大类，所以为后续构建模型做了准备工作。就可以构建模型了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span></span><br><span class="line">lpt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">style = [<span class="string">&#x27;ro-&#x27;</span>, <span class="string">&#x27;go-&#x27;</span>, <span class="string">&#x27;bo-&#x27;</span>]</span><br><span class="line">xlabels = [<span class="string">&#x27;Average stay time in working days&#x27;</span>, <span class="string">&#x27;Average stay time in the morning&#x27;</span>, <span class="string">&#x27;Average length of stay on weekends&#x27;</span>, <span class="string">&#x27;Average daily passenger flow&#x27;</span>]</span><br><span class="line"><span class="comment"># 聚类图文件名前缀</span></span><br><span class="line">pic_output = <span class="string">&#x27;output/pic_&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐一作图，作出不同样式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(model_training.k):</span><br><span class="line">    plt.figure()</span><br><span class="line">    <span class="comment"># 提取每一类</span></span><br><span class="line">    tmp = model_training.r[model_training.r[<span class="string">u&#x27;聚类类别&#x27;</span>] == i].iloc[:, :<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)):</span><br><span class="line">        plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>), tmp.iloc[j], style[i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 坐标标签</span></span><br><span class="line">    plt.xticks(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>), xlabels, rotation=<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 调整计数从1开始</span></span><br><span class="line">    plt.title(<span class="string">&#x27;Business district category%s&#x27;</span> % (i + <span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 调整底部</span></span><br><span class="line">    plt.subplots_adjust(bottom=<span class="number">0.15</span>)</span><br><span class="line">    <span class="comment"># 输出图片</span></span><br><span class="line">    plt.savefig(<span class="string">u&#x27;%s%s.png&#x27;</span> % (pic_output, i + <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>然后就可以查看output文件夹的图片了：</p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed/MyBlog/image-20210701101700587.png" alt="image-20210701101700587"></p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed/MyBlog/image-20210701101716917.png" alt="image-20210701101716917"></p><p><img src="https://cdn.jsdelivr.net/gh/Iori-yimaga/PicBed/MyBlog/image-20210701101732554.png" alt="image-20210701101732554"></p><p>注：由于中文显示问题，我把标签都改成英文了，从左到右依次是：「工作日人均停留时间」、「凌晨人均停留时间」、「周末人均停留时间」、「日均人流量」，图的标题是商圈类别1、2、3。</p><p>从这三张图分析可知:</p><p>-    「商圈类别1」：工作日人均停留时间、凌晨人均停留时间都很低，周末人均停留时间中等，日人均流量很高。比较符合商业区。</p><p>-    「商圈类别2」：工作日人均停留时间中等、凌晨和周末人均停留时间很长，日均人流量很低。比较符合居住区。</p><p>-    「商圈类型3」：工作日人均停留时间很长，凌晨和周末停留时间较少，日均人流量中等。比较符合办公区。</p><p>根据原始数据和这三张图的特点来选择建立商区，需要满足“停留时间”波动较小且在原始数据中的值较大。这样才会有比较好的收益。</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 聚类算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/2021/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2021/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-为什么要研究二叉树的遍历"><a href="#0x00-为什么要研究二叉树的遍历" class="headerlink" title="0x00 为什么要研究二叉树的遍历"></a>0x00 为什么要研究二叉树的遍历</h3><p>在计算机中，遍历本身是一个线性操作。所以遍历同样具有线性结构的数组或链表，是一件轻而易举的事情。</p><p>数组的遍历如下：</p><div class="table-container"><table><thead><tr><th>9</th><th>2</th><th>3</th><th>8</th><th>4</th><th>7</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">9 --&gt; 2;</span><br><span class="line">2 --&gt; 3;</span><br><span class="line">3 --&gt; 8;</span><br><span class="line">8 --&gt; 4;</span><br><span class="line">4 --&gt; 7;</span><br></pre></td></tr></table></figure><p>链表的遍历如下,很简单，和链表的指向结构一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">6((6)) --&gt; 3((3))</span><br><span class="line">3((3)) --&gt; 4((4))</span><br><span class="line">4((4)) --&gt; 5((5))</span><br><span class="line">5((5)) --&gt; 1((1))</span><br></pre></td></tr></table></figure><p>反观二叉树，是典型的非线性数据结构，遍历时我们需要把非线性关联的节点转换成一个线性的序列。以不同的方式来遍历，得到的结果序列顺序也不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">1((1)) --&gt; 2((2))</span><br><span class="line">1((1)) --&gt; 3((3))</span><br><span class="line">2((2)) --&gt; 4((4))</span><br><span class="line">2((2)) --&gt; 5((5))</span><br><span class="line">3((3)) --&gt; 6((6))</span><br></pre></td></tr></table></figure><p>那么，二叉树有哪些遍历方式呢？</p><p>从节点的位置关系来看的话，分为四种：</p><ol><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li><li>层序遍历</li></ol><p>从更宏观的角度来讲的话，分为两大类：</p><ol><li>广度优先遍历（层序遍历）</li><li>深度优先遍历（前序遍历、中序遍历、后序遍历）</li></ol><h3 id="0x01-深度优先遍历"><a href="#0x01-深度优先遍历" class="headerlink" title="0x01 深度优先遍历"></a>0x01 深度优先遍历</h3><h4 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1.前序遍历"></a>1.前序遍历</h4><p>口诀：根左右。具体来说就是每次遍历都遵循<strong>根节点、左子树、右子树</strong>的顺序。我们来举一个栗子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">1((1)) --&gt; 2((2))</span><br><span class="line">1((1)) --&gt; 3((3))</span><br><span class="line">2((2)) --&gt; 4((4))</span><br><span class="line">2((2)) --&gt; 5((5))</span><br><span class="line">3((3)) --&gt; 6((6))</span><br></pre></td></tr></table></figure><p>这科二叉树的遍历序列可以简化成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1 --&gt; 2</span><br><span class="line">2 --&gt; 4</span><br><span class="line">4 --&gt; 5</span><br><span class="line">5 --&gt; 3</span><br><span class="line">3 --&gt; 6</span><br></pre></td></tr></table></figure><h4 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h4><p>口诀：左根右。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">1((1)) --&gt; 2((2))</span><br><span class="line">1((1)) --&gt; 3((3))</span><br><span class="line">2((2)) --&gt; 4((4))</span><br><span class="line">2((2)) --&gt; 5((5))</span><br><span class="line">3((3)) --&gt; 6((6))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">4 --&gt; 2</span><br><span class="line">2 --&gt; 5</span><br><span class="line">5 --&gt; 1</span><br><span class="line">1 --&gt; 3</span><br><span class="line">3 --&gt; 6</span><br></pre></td></tr></table></figure><h4 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3.后序遍历"></a>3.后序遍历</h4><p>口诀：左右根。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">1((1)) --&gt; 2((2))</span><br><span class="line">1((1)) --&gt; 3((3))</span><br><span class="line">2((2)) --&gt; 4((4))</span><br><span class="line">2((2)) --&gt; 5((5))</span><br><span class="line">3((3)) --&gt; 6((6))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">4 --&gt; 5</span><br><span class="line">5 --&gt; 2</span><br><span class="line">2 --&gt; 6</span><br><span class="line">6 --&gt; 3</span><br><span class="line">3 --&gt; 1</span><br></pre></td></tr></table></figure><h4 id="4-代码环节"><a href="#4-代码环节" class="headerlink" title="4.代码环节"></a>4.代码环节</h4><p>在我们熟悉了二叉树的几种遍历方式的思想后，能实现它才是最重要的，不能光说不做对吧。</p><h5 id="递归式遍历"><a href="#递归式遍历" class="headerlink" title="递归式遍历"></a>递归式遍历</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先声明一个节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">self.data = data</span><br><span class="line">    self.left = <span class="literal">None</span></span><br><span class="line">    self.right = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create_binary_tree</span>(<span class="params">input_list=[]</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构建二叉树</span></span><br><span class="line"><span class="string">    :param input_list: 输入数列</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> input_list <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(input_list) == <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    data = input_list.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    node = TreeNode(data)</span><br><span class="line">    node.left = create_binary_tree(input_list)</span><br><span class="line">    node.right = create_binary_tree(input_list)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pre_order_traversal</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    前序遍历</span></span><br><span class="line"><span class="string">    :param node: 二叉树节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(node.data)</span><br><span class="line">    pre_order_traversal(node.left)</span><br><span class="line">    pre_order_traversal(node.right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">in_order_traversal</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    中序遍历</span></span><br><span class="line"><span class="string">    :param node:二叉树节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    in_order_traversal(node.left)</span><br><span class="line">    <span class="built_in">print</span>(node.data)</span><br><span class="line">    in_order_traversal(node.right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">post_order_traversal</span>(<span class="params">node</span>):</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      后序遍历</span></span><br><span class="line"><span class="string">      :param node: 二叉树节点</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      post_order_traversal(node.left)</span><br><span class="line">      post_order_traversal(node.right)</span><br><span class="line">      <span class="built_in">print</span>(node.data)</span><br><span class="line">      <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><p>然后我输入一个测试序列来检测是否符合结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_input_list = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">10</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">8</span>, <span class="literal">None</span>, <span class="number">4</span>]</span><br><span class="line">root = create_binary_tree(my_input_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;前序遍历：&quot;</span>)</span><br><span class="line">pre_order_traversal(root)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;中序遍历：&quot;</span>)</span><br><span class="line">in_order_traversal(root)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;后序遍历&quot;</span>)</span><br><span class="line">post_order_traversal(root)</span><br></pre></td></tr></table></figure><p>在这里，二叉树的构建流程如下，需要注意的是，列表中的None代表儿子节点为空的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">3((3)) --1--&gt; 2((2))</span><br><span class="line">2((2)) --2--&gt; 9((9))</span><br><span class="line">9((9)) --3--&gt; None_1((None))</span><br><span class="line">9((9)) --4--&gt; None_2((None))</span><br><span class="line">2((2)) --5--&gt; 10((10))</span><br><span class="line">10((10)) --6--&gt; None_3((None))</span><br><span class="line">10((10)) --7--&gt; None_4((None))</span><br><span class="line">3((3)) --8--&gt; 8((8))</span><br><span class="line">8((8)) --9--&gt; None_5((None))</span><br><span class="line">8((8)) --10--&gt; 4((4))</span><br></pre></td></tr></table></figure><h5 id="非递归式遍历（栈）"><a href="#非递归式遍历（栈）" class="headerlink" title="非递归式遍历（栈）"></a>非递归式遍历（栈）</h5><p>到这里所有代码的思想都是递归的方式进行遍历比较简单和顺畅，当然也可以利用<strong>栈</strong>这种数据结构来进行非递归遍历。我们还是利用这颗树来进行<strong>前序遍历</strong>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">1((1)) --&gt; 2((2))</span><br><span class="line">1((1)) --&gt; 3((3))</span><br><span class="line">2((2)) --&gt; 4((4))</span><br><span class="line">2((2)) --&gt; 5((5))</span><br><span class="line">3((3)) --&gt; 6((6))</span><br></pre></td></tr></table></figure><p>1、首先遍历二叉树的根节点，放入栈中</p><div class="table-container"><table><thead><tr><th>1</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>2、遍历根节点1的左孩子节点2，放入栈中</p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>3、遍历节点2的左孩子节点4，放入栈中</p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>4</th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>4、节点4没有左孩子也没有右孩子，出栈，回溯到其父节点2，2此时左孩子已访问，还有右孩子未访问，所以节点2出栈，她的右孩子节点5入栈。</p><div class="table-container"><table><thead><tr><th>1</th><th>5</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>5、节点五没有孩子节点，那么我们需要回溯，此时只有根节点1，节点5出栈，节点1出栈，节点1的右孩子节点3入栈。</p><div class="table-container"><table><thead><tr><th>3</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>6、节点三无左孩子，只有右孩子节点6，所以节点3出栈，节点6入栈</p><div class="table-container"><table><thead><tr><th>6</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>7、节点6无孩子，节点6出栈，此时栈为空，遍历结束。</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_order_teaversal_with_stack</span>(<span class="params">node</span>):</span></span><br><span class="line">  stack = []</span><br><span class="line">  <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="built_in">print</span>(node.data)</span><br><span class="line">      stack.append(node)</span><br><span class="line">      node = node.left</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">      node = stack.pop()</span><br><span class="line">      node = node.right</span><br></pre></td></tr></table></figure><h3 id="0x02-广度优先遍历"><a href="#0x02-广度优先遍历" class="headerlink" title="0x02 广度优先遍历"></a>0x02 广度优先遍历</h3><p>我们通过学习<strong>层序遍历</strong>来了解<strong>广度优先遍历</strong>是怎么回事。</p><p>层序遍历就是按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">1((1)) --&gt; 2((2))</span><br><span class="line">1((1)) --&gt; 3((3))</span><br><span class="line">2((2)) --&gt; 4((4))</span><br><span class="line">2((2)) --&gt; 5((5))</span><br><span class="line">3((3)) --&gt; 6((6))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1((1)) --&gt; 2((2))</span><br><span class="line">2((2)) --&gt; 3((3))</span><br><span class="line">3((3)) --&gt; 4((4))</span><br><span class="line">4((4)) --&gt; 5((5))</span><br><span class="line">5((5)) --&gt; 6((6))</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>怎么样，是不是很简单呢？一层一层从向往下从左往右就可以了。可是在同一层的节点之间是没有直接关联的，那我们该怎么去代码实现呢，这里我们借助<strong>队列</strong>来辅助遍历。</p><p>详细遍历步骤如下：</p><p>1、根节点1进入队列</p><div class="table-container"><table><thead><tr><th>1</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>2、节点1出队，输出节点1，并得到节点1的左孩子节点2、右孩子节点3.让节点2、3入队</p><div class="table-container"><table><thead><tr><th>2</th><th>3</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>3、节点2出队，并得到其孩子节点4、5，节点4、5入队</p><div class="table-container"><table><thead><tr><th>3</th><th>4</th><th>5</th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>4、节点3出队，并得到节点3的右孩子节点6，节点6入队</p><div class="table-container"><table><thead><tr><th>4</th><th>5</th><th>6</th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>5、节点4出队，输出节点4，但是节点4没有孩子节点，所以没有新节点入队</p><div class="table-container"><table><thead><tr><th>5</th><th>6</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>6、节点5出队，输出节点5，但是节点5没有孩子节点，故无新节点入队</p><div class="table-container"><table><thead><tr><th>6</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>7、节点6出队，输出节点6，但是节点6没有孩子节点，故无新节点入队，此时队列为空，遍历结束</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order_traversal</span>(<span class="params">node</span>):</span></span><br><span class="line">  queue = Queue()</span><br><span class="line">  queue.put(node)</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> queue.empty():</span><br><span class="line">    node = queue.get()</span><br><span class="line">    <span class="built_in">print</span>(node.data)</span><br><span class="line">    <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      queue.put(node.left)</span><br><span class="line">     <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      queue.put(node.right)</span><br></pre></td></tr></table></figure><p>Todo: </p><ul><li>[ ] 二叉堆相关</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编程学习 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集</title>
      <link href="/2021/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2021/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-收集域名信息"><a href="#0x00-收集域名信息" class="headerlink" title="0x00 收集域名信息"></a>0x00 收集域名信息</h3><h4 id="1-Whois查询"><a href="#1-Whois查询" class="headerlink" title="1. Whois查询"></a>1. Whois查询</h4><p>​     Whois是一个标准的互联网协议，可以收集网络注册信息，如域名、IP地址、服务商、域名拥有者、邮箱、电话、地址等。</p><p>–    爱站工具网（<a href="https://whois.aizhan.com">whois.aizhan.com</a>）</p><p>–    站长之家（<a href="http://whois.chinaz.com">whois.chinaz.com</a>）</p><p>–    VirtusTotal（<a href="https://www.virustotal.com">virustotal.com</a>）</p><h4 id="2-备案信息查询"><a href="#2-备案信息查询" class="headerlink" title="2. 备案信息查询"></a>2. 备案信息查询</h4><p>–    ICP备案查询网：<a href="http://www.beianbeian.com">beianbeian.com</a></p><p>–    天眼查：<a href="http://tianyancha.com">tianyancha.com</a></p><h3 id="0x01-收集敏感信息"><a href="#0x01-收集敏感信息" class="headerlink" title="0x01 收集敏感信息"></a>0x01 <strong>收集敏感信息</strong></h3><p>各种搜索引擎的黑客语法可以用来获取数据库文件、SQL注入、配置信息、源代码泄漏、未授权访问和robots.txt等敏感信息。</p><p>常见的Google语法如下：</p><div class="table-container"><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>Site</td><td>指定域名</td></tr><tr><td>Inurl</td><td>URL中存在关键字的网页</td></tr><tr><td>Intext</td><td>网页正文中的关键字</td></tr><tr><td>Filetype</td><td>指定文件类型</td></tr><tr><td>Intitle</td><td>网页标题中的关键字</td></tr><tr><td>link</td><td>link:baidu.com即表示返回所有和baidu.com做了链接的URL</td></tr><tr><td>Info</td><td>查找指定站点的一些基本信息</td></tr><tr><td>cache</td><td>搜索Google里关于某些内容的缓存</td></tr></tbody></table></div><h3 id="0x02-收集子域名信息"><a href="#0x02-收集子域名信息" class="headerlink" title="0x02 收集子域名信息"></a>0x02 <strong>收集子域名信息</strong></h3><h4 id="1-常用工具"><a href="#1-常用工具" class="headerlink" title="1. 常用工具"></a>1. 常用工具</h4><p>–    Layer子域名挖掘机 简单易用，安全测试人员常用</p><p>–    subDomainBrute 可以用小字典递归发现多级域名</p><p>–    Sublist3r 可以列举多种资源，如Google、Yahoo、Bing、Netcraft、ThreadCrowd等查到的子域名</p><h4 id="2-搜索引擎枚举"><a href="#2-搜索引擎枚举" class="headerlink" title="2. 搜索引擎枚举"></a>2. 搜索引擎枚举</h4><h4 id="3-第三方聚合应用枚举"><a href="#3-第三方聚合应用枚举" class="headerlink" title="3. 第三方聚合应用枚举"></a>3. 第三方聚合应用枚举</h4><p>也可以用DNSdumpster网站（<a href="http://dnsdumpster.com">dnsdumpster.com</a>）、在线DNS侦查和搜索工具挖掘出指定域潜藏的大量子域。</p><h4 id="4-证书透明度公开日志枚举"><a href="#4-证书透明度公开日志枚举" class="headerlink" title="4. 证书透明度公开日志枚举"></a>4. 证书透明度公开日志枚举</h4><p>证书授权机构会将每个SSL/TLS证书发布到公共日志中。一个SSL/TLS证书通常包含域名、子域名和邮箱地址。</p><p>–    crt.sh: <a href="https://crt.sh">crt.sh</a></p><p>–    censys: <a href="https://censys.io">censys.io</a></p><p>–    子域名爆破网站（<a href="https://phpinfo.me/domain">phpinfo.me/domain</a>）</p><p>–    IP反查域名绑定网站（<a href="http://aizhan.com">aizhan.com</a>）</p><h3 id="0x03-收集常用端口信息"><a href="#0x03-收集常用端口信息" class="headerlink" title="0x03 收集常用端口信息"></a>0x03 <strong>收集常用端口信息</strong></h3><p>常见端口号对应服务如下表</p><p>–    <strong>文件共享服务类</strong></p><div class="table-container"><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方向</th></tr></thead><tbody><tr><td>21/22/69</td><td>Ftp/Tftp文件传输协议</td><td>允许匿名的上传、下载、爆破和嗅探</td></tr><tr><td>2049</td><td>Nfs服务</td><td>配置不当</td></tr><tr><td>139</td><td>Samba服务</td><td>爆破、未授权访问、远程代码执行</td></tr><tr><td>389</td><td>Ldap目录访问协议</td><td>注入、允许匿名访问、弱口令</td></tr></tbody></table></div><p>–    <strong>远程连接服务类</strong></p><div class="table-container"><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方向</th></tr></thead><tbody><tr><td>22</td><td>SSH远程连接</td><td>爆破、SSH隧道及内网代理转发、文件传输</td></tr><tr><td>23</td><td>Telnet远程连接</td><td>爆破、嗅探、弱口令</td></tr><tr><td>3389</td><td>Rdp远程桌面连接</td><td>Shift后门（需要Windows Server 2003一下系统）爆破</td></tr><tr><td>5900</td><td>VNC</td><td>弱口令爆破</td></tr><tr><td>5632</td><td>PyAnywhere服务</td><td>抓密码、代码执行</td></tr></tbody></table></div><p>–    <strong>Web</strong> <strong>应用服务类</strong></p><div class="table-container"><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方向</th></tr></thead><tbody><tr><td>80/443/8080</td><td>常见的Web服务端口</td><td>Web攻击、爆破、对应服务器版本攻击</td></tr><tr><td>7001/7002</td><td>WebLogic控制台</td><td>Java反序列化、弱口令</td></tr><tr><td>8080/8089</td><td>Jboss/Resin/Jetty/Jenkins</td><td>反序列化、控制台弱口令</td></tr><tr><td>9090</td><td>WebSphere控制台</td><td>Java反序列化、弱口令</td></tr><tr><td>4848</td><td>GlassFish控制台</td><td>弱口令</td></tr><tr><td>1352</td><td>Lotus domino邮件服务</td><td>弱口令、信息泄漏、爆破</td></tr><tr><td>10000</td><td>Webmin-Web控制面板</td><td>弱口令</td></tr></tbody></table></div><p>–    <strong>数据库服务类</strong></p><div class="table-container"><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方向</th></tr></thead><tbody><tr><td>3306</td><td>MySQL</td><td>注入、提权、爆破</td></tr><tr><td>1433</td><td>MSSQL数据库</td><td>注入、提权、SA弱口令、爆破</td></tr><tr><td>1521</td><td>Oracle数据库</td><td>TNS爆破、注入、反弹shell</td></tr><tr><td>5432</td><td>PostSQL数据库</td><td>注入、爆破、弱口令</td></tr><tr><td>27017/27018</td><td>MongoDB</td><td>爆破、未授权访问</td></tr><tr><td>6379</td><td>Redis数据库</td><td>可尝试未授权访问、弱口令爆破</td></tr><tr><td>5000</td><td>SysBase/DB2数据库</td><td>爆破、注入</td></tr></tbody></table></div><p>–    <strong>邮件服务类</strong></p><div class="table-container"><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方式</th></tr></thead><tbody><tr><td>25</td><td>SMTP邮件服务</td><td>邮件伪造</td></tr><tr><td>110</td><td>POP3协议</td><td>爆破、嗅探</td></tr><tr><td>143</td><td>IMAP协议</td><td>爆破</td></tr></tbody></table></div><p>–    <strong>网络常见协议类</strong></p><div class="table-container"><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方式</th></tr></thead><tbody><tr><td>53</td><td>DNS域名系统</td><td>允许区域传送、DNS劫持、缓存投毒、欺骗</td></tr><tr><td>67/68</td><td>DHCP服务</td><td>劫持、欺骗</td></tr><tr><td>161</td><td>SNMP协议</td><td>爆破、搜集目标内网信息</td></tr></tbody></table></div><p>–    <strong>特殊服务类</strong></p><div class="table-container"><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击方式</th></tr></thead><tbody><tr><td>2181</td><td>ZooKeeper服务</td><td>未授权访问</td></tr><tr><td>8069</td><td>Zabbix服务</td><td>远程执行、SQL注入</td></tr><tr><td>9200/9300</td><td>Elasticsearch服务</td><td>未授权访问</td></tr><tr><td>11211</td><td>Memcache服务</td><td>未授权访问</td></tr><tr><td>512/513/514</td><td>Linux Rexec服务</td><td>爆破、Rlogin服务</td></tr><tr><td>873</td><td>Rsync服务</td><td>匿名访问、文件上传</td></tr><tr><td>3690</td><td>Svn服务</td><td>Svn泄漏、未授权访问</td></tr><tr><td>50000</td><td>SAP Management Console</td><td>远程执行</td></tr></tbody></table></div><h3 id="0x04-指纹识别"><a href="#0x04-指纹识别" class="headerlink" title="0x04 指纹识别"></a>0x04 指纹识别</h3><p>​    应用程序一般在html、js、css等文件中会存在一些特征码，比如WordPress在robots.txt中会包含wp-admin\首页index.php中会包含generator=wordpress 3.xx等信息。这就叫做该CMS的指纹。</p><p>​    常见的CMS有Dedecms（织梦）、Discuz、PHPWEB、PHPWind、PHPCMS、ECShop、Dvbbs、SiteWeaver、ASPCMS、帝国、Z-Blog、WordPress等。</p><p>​    代表工具也有御剑Web指纹识别、WhatWeb、WebRobo、椰树等，当然也可以利用一些在线网站查询CMS指纹识别：</p><p>–    BugScanner：<a href="http://whatweb.bugscaner.com/look/">whatweb.bugscaner.com/look/</a></p><p>–    云悉指纹: <a href="http://www.yunsee.cn/finger.html">www.yunsee.cn/finger.html</a></p><p>–    WhatWeb:<a href="https://whatweb.net/">whatweb.net</a></p><h3 id="0x05-查找真实IP"><a href="#0x05-查找真实IP" class="headerlink" title="0x05 查找真实IP"></a>0x05 查找真实IP</h3><p><strong>1.</strong> <strong>判断目标网站是否使用了</strong> <strong>CDN</strong> <strong>（即内容分发网络，可以提高网站的响应速度）</strong></p><p>​    如果目标服务器有CDN服务，我们直接ping域名的话，得到的会是离我们最近的一台目标节点的CDN服务器，这时我们可以利用在线网站17CE（<a href="https://17ce.com">17ce.com</a>）进行全国多地区的ping服务器操作，然后对比每个地区的ping出IP的结果，看看是否一致，如果都是一样的，那么目标不存在CDN服务器，如果IP大多不一样或着有规律性，则可以尝试查询这些IP的归属地，判断是否有CDN。</p><p><strong>2.</strong> <strong>绕过</strong> <strong>CDN</strong> <strong>寻找真实</strong> <strong>IP</strong></p><p>–    内部邮箱源。一般的邮件系统存在内部，没有经过CDN的解析，通过目标网站用户注册或者RSS订阅功能，查看邮件、寻找邮件头中的邮件服务器域名IP，ping这个邮件服务器域名，就能获取目标真实IP（当然这个服务器必须是目标自己的，若是第三方公共邮箱就没有意义了）</p><p>–    扫描网站测试文件，如phpinfo、test等，从而找到真实的IP。</p><p>–    分站域名。一般的都是主站挂CDN但是分站没有，可能会出现不是同一个IP但是在同一个c段下的情况。从而可以判断出目标的真实IP段。</p><p>–    国外访问。国内的CDN只针对国内用户访问加速，但是国外的CDN就不一定了。通过国外在线代理网站APP Synthetic Monitor（<a href="http://asm.ca.com/en/ping.php">asm.ca.com/en/ping.php</a>）访问，可能会得到真实的IP。</p><p>–    查询域名的解析记录。可以通过网站NETCRAFT（<a href="http://netcraft.com">netcraft.com</a>）来观察域名的IP历史记录，也可以大致分析出目标的真实IP段。</p><p>–    如果目标网站有自己的App，可以尝试抓包，从数据包内分析真实IP</p><p>–    绕过CloudFlare CDN查找真实IP。很多网站都使用了CloudFlare提供的CDN服务，可以尝试通过在线网站CloudFlareWatch（<a href="http://www.crimeflare.us/cfs.html#box">www.crimeflare.us/cfs.html#box</a>）对CloudFlare客户网站进行真实的IP查询</p><p><strong>3.</strong> <strong>验证获取的</strong> <strong>IP</strong></p><p>最简单的就是访问IP，比较访问域名返回的结果是否一致，若目标段较大，可以借助Masscan的工具批量扫描对应IP段中所有开了80、8080、443端口的IP，逐个访问。</p><h3 id="0x06-收集敏感目录文件"><a href="#0x06-收集敏感目录文件" class="headerlink" title="0x06 收集敏感目录文件"></a>0x06 收集敏感目录文件</h3><p>在渗透测试中，探测Web目录结构和隐藏的敏感文件是一个必不可少的环节，从中可以获取网站的后台管理页面、文件上传界面，甚至源代码。</p><p>针对网站目录扫描主要有：DirBuster、御剑后台扫描珍藏版、wwwscan、Spinder.py、Sensitivefilescan、Weakfilescan等工具。也可以访问在线网站WebScan（<a href="http://www">www</a>.webscan.cc/）</p><h3 id="0x07-社会工程学"><a href="#0x07-社会工程学" class="headerlink" title="0x07 社会工程学"></a>0x07 社会工程学</h3><p>针对人来下手。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Web安全攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nmap小技巧</title>
      <link href="/2021/Nmap%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2021/Nmap%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-Nmap列举远程机器开放的端口原理"><a href="#0x00-Nmap列举远程机器开放的端口原理" class="headerlink" title="0x00 Nmap列举远程机器开放的端口原理"></a>0x00 Nmap列举远程机器开放的端口原理</h3><p>首先判断nmap输入的命令中是否包含域名，如果包含需要利用DNS服务器进行域名解析，然后发送ICMP Echo Request来探测主机的存活性。若目标主机存活，nmap则向目标发送数据包，然后目标主机会做出回应，回包给nmap，nmap就根据返回的数据包来得到机器信息，其中就包含端口信息。</p><h5 id="可以使用【nmap-domain-name】来探测"><a href="#可以使用【nmap-domain-name】来探测" class="headerlink" title="可以使用【nmap domain_name】来探测"></a>可以使用【nmap domain_name】来探测</h5><ul><li>nmap在探测之前把域名通过DNS服务器解析为IP地址，也可以用执行的DNS服务器进行解析。使用          —dns-server参数来指定</li><li>对于已知主机存活或者防火墙开启的机器，可以使用-Pn参数来停止探测之前的ICMP请求。以达到不触发防火墙安全机制。</li><li>对于默认的端口范围，不能满足日常需要。可以使用-p m-n来指定探测端口范围之间的所有端口</li></ul><h5 id="端口状态："><a href="#端口状态：" class="headerlink" title="端口状态："></a>端口状态：</h5><ul><li>Open               表示端口处于开放状态</li><li>Closed             关闭</li><li>Filterd              表示端口处于过滤无法收到返回的probe状态</li><li>UnFilterd         表示端口收到返回的probe，但是无法确认</li><li>Opened/UnFilterd       表示端口处于开放或者是过滤状态</li><li>Closed/UnFilterd          表示端口处于关闭或者是未过滤状态</li></ul><h3 id="0x01-Nmap发现局域网中存活主机"><a href="#0x01-Nmap发现局域网中存活主机" class="headerlink" title="0x01 Nmap发现局域网中存活主机"></a>0x01 Nmap发现局域网中存活主机</h3><h4 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h4><ul><li><p><code>ping ip</code> 手工探测，但是很费劲</p></li><li><p>CIDR（无类别域间路由），可以快速表示一个网络</p><p><code>172.16.1.1/24 = 172.16.1.1～172.16.1.255</code> 表示该域下所有主机IP地址</p></li><li><p><code>nmap -sP CIDR</code> 对该网络所有的主机进行Ping扫描，以探测主机存活性。扫描过程中使用了<strong>TCP、SYN扫描</strong>、<strong>ICMP echo Request来探测主机存活</strong></p></li><li><p><code>nmap -sn CIDR</code> 对网络中所有主机进行Ping扫描，探测主机的存活性</p></li><li><p><code>nmap -sn CIDR -oX file_name.xml</code> 将探测结果保存到xml文件中</p></li></ul><h3 id="0x02-Nmap识别目标机器上服务的指纹"><a href="#0x02-Nmap识别目标机器上服务的指纹" class="headerlink" title="0x02 Nmap识别目标机器上服务的指纹"></a>0x02 Nmap识别目标机器上服务的指纹</h3><h4 id="服务指纹"><a href="#服务指纹" class="headerlink" title="服务指纹"></a>服务指纹</h4><p>为了确保有一个成功的滲透测试或网络设备监控，必须知道目标系统中服务的指纹信息。服务指纹信息包括服务端口、服务名和版本等。</p><p>通过分析目标往Nmap发送的数据包中某些协议标记、选项和数据，我们可以推断发送这些数据包的操作系统等。</p><p> nmap通过向目标主机发送多个UDP与TCP数据包冰分析其响应来进行操作系统指纹识别工作。</p><p>使用命令<code>nmap -sV IP</code>来识别目标机器的服务信息</p><p><strong>Nmap的倾略性探测</strong></p><ul><li><code>nmap -A -v -T4 IP</code>  </li><li><code>nmap -sC -sV -O IP</code></li></ul><p>以上两条命令都是使用Nmap来探测目标机器的操作系统、服务等信息。其中<code>-sC</code>表示使用Nmap脚本探测，<code>-sV</code>表示探测目标服务器上的服务信息，<code>-O</code>表示探测目标服务器的操作系统信息。</p><p>Tips：<code>-sC:equivalent to -script=default</code></p><h3 id="0x03-Nmap的NSE脚本使用"><a href="#0x03-Nmap的NSE脚本使用" class="headerlink" title="0x03 Nmap的NSE脚本使用"></a>0x03 Nmap的NSE脚本使用</h3><h4 id="NSE脚本介绍"><a href="#NSE脚本介绍" class="headerlink" title="NSE脚本介绍"></a>NSE脚本介绍</h4><p> NSE（Nmap Script Engine）Nmap脚本引擎，内置很多可以用来扫描的、针对特定任务的脚本。通过NSE可以不断拓展Nmap扫描策略，加强Nmap的功能。</p><p> Nmap中使用—script参数来指定调用的脚本，并且脚本存储在Nmap安装路径下的script文件夹下，对于kali linux存储在/usr/share/nmap/script/下。</p><h4 id="NSE使用"><a href="#NSE使用" class="headerlink" title="NSE使用"></a>NSE使用</h4><ul><li><code>nmap --script script_name IP</code>         使用Nmap探测Web服务的title信息</li><li><code>nmap --script http-headers IP</code>       使用Nmap探测http服务的http头</li></ul><h4 id="NSE分类使用"><a href="#NSE分类使用" class="headerlink" title="NSE分类使用"></a>NSE分类使用</h4><p>对于目标使用多个分类脚本进行探测，可以更快的找到目标的信息与弱点。</p><ul><li><p>使用Nmap中漏洞分类脚本对目标进行探测，使用命令如下：</p><p><code>nmap -sV --script vuln IP</code></p></li><li><p>使用Nmap中发现和版本信息分类进行探测，使用命令如下：</p><p><code>nmap -sV --script=&quot;version, discovery&quot; IP</code></p></li><li><p>使用Nmap除了exploit分类之外的其它分类进行探测，使用命令如下：</p><p><code>nmap -sV --script=&quot;not exploit&quot; IP</code></p></li><li><p>使用Nmap中http*的脚本，但是除了（http-brute和http-slowlors）,使用命令如下：</p><p><code>nmap -sV --script &quot;(http*) and not (http-slowlors and http-brute)&quot; IP</code></p></li></ul><h3 id="0x04-Nmap端口探测小技巧"><a href="#0x04-Nmap端口探测小技巧" class="headerlink" title="0x04 Nmap端口探测小技巧"></a>0x04 Nmap端口探测小技巧</h3><ul><li><code>nmap -p port_number ip</code> 对某个端口进行探测</li><li><code>nmap -p port_number1,port_number2... IP</code>  对某几个端口进行探测</li><li><code>nmap -p1-100 ip</code>  对某个范围端口进行探测</li><li><code>nmap -p- ip</code>  全端口探测</li><li><code>nmap -p T:25,U:53 IP</code>  指定协议来探测端口</li><li><code>nmap -p smtp IP</code>  通过协议名来扫描端口</li><li><code>nmap -p s* ip</code>  通过名称范围扫描</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题分享</title>
      <link href="/2021/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB/"/>
      <url>/2021/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>今天又折腾了一下博客，想着慢慢积累知识并定期分享出来，当然也是监督自己时刻都在学习，然后现在把之前面试中遇到的问题归纳了一下，各位大佬肯定觉得很简单，但也是对我早期学习经历的一次总结吧。</p><h4 id="Python常用小脚本"><a href="#Python常用小脚本" class="headerlink" title="Python常用小脚本"></a>Python常用小脚本</h4><ul><li>端口扫描</li></ul><ul><li>文件上传</li></ul><ul><li>TCP交互</li></ul><ul><li>目录扫描</li></ul><h4 id="文件上传如何绕WAF"><a href="#文件上传如何绕WAF" class="headerlink" title="文件上传如何绕WAF"></a>文件上传如何绕WAF</h4><p>首先猜测WAF类型：</p><p>​    D盾file_nameH改变大小写、连等号（3个）===、回车 file_name=====”index.pHp”或其它的各种解析漏洞</p><p>WAF的动态二进制查杀&lt;-内容，太大了不会全部查看</p><h4 id="MySQL数据库下有哪些默认数据库"><a href="#MySQL数据库下有哪些默认数据库" class="headerlink" title="MySQL数据库下有哪些默认数据库"></a>MySQL数据库下有哪些默认数据库</h4><p>information_schema:储存其它数据库的表名和字段名</p><h4 id="MySQL提权有哪些手段"><a href="#MySQL提权有哪些手段" class="headerlink" title="MySQL提权有哪些手段"></a>MySQL提权有哪些手段</h4><ul><li>UDF提权</li></ul><ul><li>写文件提权（要知道网站的绝对路径）</li></ul><h4 id="CSRF如何利用"><a href="#CSRF如何利用" class="headerlink" title="CSRF如何利用"></a>CSRF如何利用</h4><p>XSS联动利用</p><h4 id="SSRF如何利用"><a href="#SSRF如何利用" class="headerlink" title="SSRF如何利用"></a>SSRF如何利用</h4><p>file:///读文件</p><p>dict:///主机探活</p><h4 id="内网怎么横向渗透"><a href="#内网怎么横向渗透" class="headerlink" title="内网怎么横向渗透"></a>内网怎么横向渗透</h4><p>假设现在有A主机、B主机</p><p>Cweb服务器&lt;—— mimikatz 抓取密码hash爆破</p><p>windows然后3389远程登录</p><p>administrator、admin</p><p>linux 22端口登录</p><p>root、webroot、admin</p><p>arp探测主机存活性</p><p>端口探测80端口、探测资产</p><h4 id="CDN如何绕过"><a href="#CDN如何绕过" class="headerlink" title="CDN如何绕过"></a>CDN如何绕过</h4><p>多地址ping请求 <a href="http://www.chinaz.com">www.chinaz.com</a></p><p>查看DNS历史记录 <a href="http://www.dnsdb.io/zh-cn/">www.dnsdb.io/zh-cn/</a></p><h4 id="SQL注入怎么绕WAF"><a href="#SQL注入怎么绕WAF" class="headerlink" title="SQL注入怎么绕WAF"></a>SQL注入怎么绕WAF</h4><ul><li>大小写绕过 pHp</li></ul><ul><li>双写绕过   str_replace(find, replace, string, count)  pphphp</li></ul><ul><li>注释符绕过</li></ul><ul><li>函数截断 substr left() right()</li></ul><h4 id="文件上传的解析漏洞有了解过吗"><a href="#文件上传的解析漏洞有了解过吗" class="headerlink" title="文件上传的解析漏洞有了解过吗"></a>文件上传的解析漏洞有了解过吗</h4><p>多后缀解析漏洞：Apache的文件解析顺序是从右向左，它会解析它认得的 text.php.345.fgd.jfd,那么会被解析成php文件</p><p>用hex功能在1.php后面加一个\x0A</p><p>IIS6.0 test.php;.jpg test.php4/5/7 test.phtml/phpr</p><p>IIS7.5 test.jpg/.php</p><p>Windows::$DATA 00截断</p><h4 id="XSS只能盗取cookie吗"><a href="#XSS只能盗取cookie吗" class="headerlink" title="XSS只能盗取cookie吗"></a>XSS只能盗取cookie吗</h4><p>粘贴板漏洞攻击</p><p>盗链、暗链</p><h4 id="说一下SQL注入原理"><a href="#说一下SQL注入原理" class="headerlink" title="说一下SQL注入原理"></a>说一下SQL注入原理</h4><p>攻击者通过构造恶意的SQL语句传入到数据库中，执行后破坏了原有的语法结构。</p><p>漏洞挖掘、闭合-&gt;字段-&gt;显示位置-&gt;数据库名（MySQL）-&gt;表名-&gt;列名-&gt;敏感数据</p><p>利用SQL注入写文件（木马）-&gt;file_input D:/web/data/-&gt;Sqlmap —os-shell</p><p>平时怎么去挖掘：平时注意与数据库交互的一些参数，不要放过每一个参数，尤其关注后台、内网的一些参数点。</p><p>SQL防护 PDO、预编译</p><ul><li>[ ] 了解过XXE吗？</li><li>[ ] 用最简单的方式判断sql注入的数据库类型</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/hello-world/"/>
      <url>/2021/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
